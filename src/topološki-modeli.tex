\section{Topološki modeli}\label{sec:modeli}

% Teorija modelov morda zveni kot zelo abstraktna in filozofska zadeva (govora je
% o matematičnih svetovih), vendar je pa ideja sama blizu vsakemu matematiku, ki
% je dokončal drugi letnik dodiplomskega študija.
% Situacija je namreč zelo podobna teoriji grup. Struktura grupe je skupek
% aksiomov (tako kot jih ima konstruktivna logika ali pa teorija množic), medtem
% ko so pa grupe same natanko \emph{modeli} teh aksiomov, in na model logike
% mislimo na isti način.

% Seveda pa grupe niso edina struktura, za katero lahko izvedemo to analogijo.
% Lahko tudi gledamo modele monoidne, kolobarske, vektorske,~itd.~strukture, prav
% tako pa lahko gledamo modele topološke strukture ali pa modele izračunljivostne
% strukture (recimo turingove stroje).

% V logiki in teoriji množic, se pogosto sprašujemo, ali so kakšne trditve
% \emph{neodvisne} od aksiomov našega sistema. Na primer aksiom izbire je
% neodvisen od preostalih aksiomov teorije množic, hipoteza kontinuuma je
% neodvisna od teorije množic z izbiro,~itd. Neodvisnost je mogoče malce
% nedostopen pojem, še posebej za matematike, ki verjamejo v absolutno resnico.
% Namreč, kako lahko trditev ni niti resnična niti neresnična? Ampak bistvo je v
% tem, da trditev ima resničnostno vrednost \emph{v vseh modelih}, vendar če je ta
% resničnostna vrednost različna v različnih modelih, je trditvi ne moremo
% dodeliti, tako da bo bilo to res v vseh modelih! Ključno je namreč, da noben
% model logike ni \emph{odlikovan}, torej nimamo \quot{standardnega modela}.

% To se vse sliši nekoliko komplicirano, a nam je zares že intimno znano. V
% teoriji grup namreč vemo za \quot{komutativnost}, za katero vemo, da se je ne da
% dokazati iz aksiomov grupe, prav tako pa ne velja njena negacija. To pa vemo
% natanko zato, ker obstajajo in komutativne in nekomutativne grupe (oziroma
% modeli aksiomov grup). V teoriji grup prav tako nimamo \quot{standardne grupe},
% za katero velja natanko vse kar velja za vse grupe.

% V logiki takim stvarem pravimo \quot{neodvisne trditve}, v teoriji
% izračunljivosti tem pravimo \quot{neizračunljive funkcije}, v algebri in
% topologiji pa \quot{lastnosti algebraične strukture oz.~topološkega prostora}.

% Skratka, prehod med aksiomatskim sistemom in modeli nam je kot matematikom znan,
% v algebri smo bili z njim vzgojeni že od malega, a v logiki te sreče žal nismo
% imeli. Tako se moramo na stara leta pruičiti teh metod, ki so pa logikom brez
% dvoma enako pomembne kot so grupe algebrajikom, ali pa prostori topologom.

% Kot smo pa omenili v uvodu, pa obstajajo modeli logike, ki so zgrajeni iz
% topoloških prostorov. Tem pravimo topološki modeli, in vse logične trditve v tem
% modelu se prevedejo v topološke trditve o topološkem prostoru. Sledi naravno
% vprašanje, ali lahko vzpostavimo nekak slovar med neodvisnimi trditvami
% (t.~j.~klasičnimi principi v konstruktivni logiki) in topološkimi lastnostmi, ki
% so nam znane.

% Do tega se vrnemo kasneje, v naslednjem razdelku, za zdaj nas pa čaka malo
% teorije snopov, da lahko topološke modele sploh definiramo.

% TODO: rewrite

% Oglejmo si najprej primer zveznih funkcij iz \(X\) v \(ℝ\).
% Zanje se vedno lahko vprašamo, če so pozitivne, negativne, ali so gladke,
% ipd.~vendar nas pogosto zanima tudi \emph{kje} za določeno funkcijo neka
% lastnost velja. Recimo preprosto, da je \(f : ℝ → ℝ\) identiteta. Tedaj je
% pozitivna na \((0,∞)\), negativna na \((-∞,0)\), gladka pa na celem \(ℝ\).
% Klasično je pozitivnost funkcije resničnostna vrednost. Z drugimi besedami,
% pozitivnost je predikat na (zveznih) realnih funkcijah. Mi pa zares želimo
% opredeliti, kje ta lastnost velja, ne zgolj če velja na celem prostoru.
% Želimo torej, da ima ``prava'' pozitivnost vrednosti v podmnožicah prostora
% \(X\), in da bo imela topologija \(X\) kaj vpliva naj bodo to zgolj odprte
% podmnožice.

% Želimo pa tudi obravnavati funkcije, ki niso definirane na celotni domeni, na
% primer \(x ↦ x⁻¹\). Tako naš primer razširimo na množico vseh funkcij \(U → ℝ\),
% kjer je \(U ∈ 𝒪X\), in označimo množico vseh teh funkcij z \(R\). Potem pa za
% \(f ∈ R\) definiramo \emph{definicijsko območje} oziroma \emph{razpon} kot
% domeno funkcije \(f\), in ga označimo \(‖f‖\).
% Na to množico lahko sedaj uvedemo predikat enakosti, ki seveda meri, na kateri
% množici se dve funkciji ujemata, na očiten način:
% \[ ⟦f = g⟧ = \int\set{t ∈ ‖f‖∩‖g‖}{f(t) = g(t)}\text. \]

% Ni naključje, da preslikavam \(R → 𝒪X\) pravimo predikati, saj se da pokazati,
% da za vsako polno Heytingovo algebro (kar \(𝒪X\) je) obstaja nek model
% konstruktivne matematike, tako da so resničnostne vrednosti natanko odprte
% množice \(X\). V tem smislu \(⟦f = g⟧\) predstavlja kar enakost med funkcijami,
% \(‖f‖\) je pa predikat obstoja elementa \(‖f‖ = \exist{f : R}{⊤}\). Velja tudi
% enakost \(‖f‖ = ⟦f = f⟧\), torej zares predikata \(‖-‖\) ne potrebujemo.

% V splošnem, množicam kot so \(R\), torej takim, da imajo definirano enakost z
% vrednostmi v \(𝒪X\) pravimo \emph{Heytingovo vrednotene množice},
% \emph{\(𝒪X\) vrednotene množice}, ali na kratko \emph{\(𝒪X\)-množice}.

V tem razdelku najprej podrobno opišemo, kako interpretiramo logiko odprtih
množic v topološkem prostoru samem. Kasneje potem to logiko razširimo do logike
višjega reda, kar nam tvori \emph{topološki model}. V tem delu ne razvijemo vseh
detajlov formalno, le predstavimo teorijo topoloških modelov na tak način, da bo
najbolj koristna za rabo v kasnejših poglavjih. Za natančne detajle o
intuicionistični logiki delnih elementov si lahko ogledate~\cite{Scott79}. Za
detajle o konstrukciji modelov te logike si lahko ogledate~\cite{FS79}, in za
detajle o bolj računskih lastnostih teh modelov~\cite[pogl.~2.6-2.8]{Borceux94}.

To teorijo se navadno razvija za okoliše, ki so alternativen način definicije
topološkega prostora, ki deluje neposredno z odprtimi množicami. Izkaže se, da
lahko več topoloških prostorov predstavlja isti okoliš, a ključno je, da je ta
okoliš natanko Kolmogorovov kvocient teh prostorov, ki je za vse enak. To pa
pomeni, da je naša teorija določena le do Kolmogorovovega kvocienta natančno,
torej bomo predpostavili, da so vsi naši prostori \(T₀\).

\subsection{Logika odprtih množic}\label{sec:modeli-logika-odprtih}

Naj bo \(X\) topološki prostor. Podrobno si oglejmo kako logične operacije
delujejo v logiki odprtih množic.

Ker vsako odprto množico interpretiramo kot resničnostno vrednost, nam torej
\(U ⊆ X\) predstavlja ``resnico na \(U\)''. To pomeni, da je \emph{resnica}
\(⊤\) kar \(X\), in \emph{neresnica} \(⊥\) \(∅\). Tu smo vzeli prazno množico,
ker neresnica ni nikjer res, torej mora imeti resničnostno vrednost prazne
množice.

Najlažje si je to predstavljati na primeru resničnostne vrednosti pozitivnosti
realne funkcije \(f : X → ℝ\). Funkcija \(f\) je pozitivna natanko tedaj, ko je
vrednost \(f > 0\) enaka \(X\). Prav tako bo nepozitivna, ko je vrednost enaka
\(∅\). Drugače rečeno, je \(f\) pozitivna natanko tedaj, ko je \(f > 0\) res, a
ko \(f > 0\) \emph{ni} res, oziroma, ko je res njena negacija, je funkcija
\emph{nepozitivna}, torej je povsod manjša ali enaka \(0\). Če je pa \(f\) na
primer identiteta \(\id : ℝ → ℝ\), ki ni niti pozitivna, niti nenegativna, je pa
vrednost \(\id > 0\) enaka \(\p{0,∞}\), medtem ko je vrednost \(¬(\id > 0)\)
enaka \(\p{-∞,0}\), ne \((-∞,0]\). To je zato, ker je vrednost trditve največja
odprta množica, na kateri trditev velja. Na množici \((-∞,0]\) že velja
\(¬(\id>0)\), a je nad prostorom \(ℝ\) njena vrednost le \emph{notranjost} te
množice. Negacija v logiki odprtih množic torej ni komplement! Izkaže se, da
moramo vzeti notranjost komplementa, oziroma njeno
\emph{zunanjost}~\angl{exterior}.

Naj bosta \(U\) in \(V\) recimo vrednosti pozitivnosti realnih funkcij \(f\) in
\(g\). Konjunkcijo \(U ∧ V\) potem beremo kot ``funkciji \(f\) in \(g\) sta obe
pozitivni'', kar je res natanko na preseku množic \(U\) in \(V\). Podobno je
disjunkcija \(U ∨ V\) natanko unija \(U\) in \(V\).
% Za negacijo moramo malo razmisliti. Izraz \(f > 0\) lahko preprosto negiramo, in
% dobimo pogoj \(f ≤ 0\), ampak množica \(t ∈ X\) za katere to drži tudi ni odprta
% (in je natanko komplement \(U\), kar bi bil drugi kandidat za negacijo \(U\)).
% Ampak lahko pa vzamemo njeno notranjost, torej ``največjo odprto množico, na
% kateri \(f > 0\) ne velja''. Temu se potem reče tudi ``zunanjost množice
% \(U\)'', označeno \(\ext{U}\), iz angleško ``\foreignlanguage{english}{exterior}''.

Implikcije med množicama pa v matematiki ponavadi ne vidimo, tako da nam tudi
naša geometrijska slika ne bo veliko pomagala. Implikacija med množicama
\(A, B ⊆ X\) se definira dokaj intuitivno kot \(\set{x ∈ X}{x ∈ A ⇒ x ∈ B}\).
V klasični metateoriji je potem ta množica kar enaka \(B ∪ Aᶜ\). Res,
implikacija zgoraj je natanko \(x ∈ B ∨ x ∉ A\), oziroma \(x ∈ B ∪ Aᶜ\). Ampak
ta množica za \(U\) in \(V\) ni nujno odprta, tako da moramo spet vzeti njeno
notranjost, torej \(U ⇒ V\) je \(\int{\p{V ∪ Uᶜ}}\).
Implikacijo bi lahko tudi definirali drugače, saj se izkaže, da je natanko
karakterizirana z naslednjo lemo.
\begin{lema}
  Za vsak \(W ∈ 𝒪X\) je \(W ⊆ U ⇒ V\) natanko tedaj, ko je \(W ∩ U ⊆ V\).
\end{lema}
\begin{dokaz}
  Najprej preoblikujmo desno vsebovanost, saj lahko rečemo da že na nivoju
  množic, velja, da je \(W ∩ U ⊆ V\) natanko tedaj, ko je \(W ⊆ V ∪ Uᶜ\).
  Potem je pa po definiciji \(U ⇒ V\) največja odprta podmnožica \(V ∪ Uᶜ\),
  tako da bo gornja ekvivalenca očitno veljala, v eno smer ker je
  \(U ⇒ V ⊆ V ∪ Uᶜ\), v drugo smer pa ker je to največja taka množica.
\end{dokaz}

V klasični matematiki se pogosto reče, da je implikacija \(U ⇒ V\) kar
definirana kot \(V ∨ ¬U\), torej \(V ∪ \int{\p{Uᶜ}}\), ampak to v tem primeru ne
drži, kar vemo tudi iz konstruktivne matematike. Res, pokažemo lahko, da če
velja \(U ⇒ V = V ∨ ¬U\), velja princip izključene tretje možnosti.Za
implikacijo si verjetno želimo, da velja \(U ⇒ U\) za vse \(U\). Ampak če velja
gornja enakost, bi to pomenilo, da velja \(U ∨ ¬U\) za vse \(U\), kar je pa
natanko princip izključene tretje možnosti.
% Naj bo recimo \(X\) prostor
% Sierpinskijeva, torej prostor z dvema točkama \(0\) in \(1\), kjer je zgolj
% točka \(1\) odprta. Potem je pa negacija \(U ≔ \{1\}\) prazna množica, in je
% \(U ∨ ¬U = U ≠ X\). Logika tega prostora ni klasična, in tam gornja enakost ne
% velja.
Imamo torej sledeči slovar:
\begin{table}[h]
  \centering
  \begin{tabularx}{0.5\textwidth}{C|C}
    Logika    & Topologija\\
    \hline
    \(⊤\)     & \(X\)\\
    \(⊥\)     & \(∅\)\\
    \(U ∧ V\) & \(U ∩ V\)\\
    \(U ∨ V\) & \(U ∪ V\)\\
    \(¬U\)    & \(\ext{U}\)\\
    \(U ⇒ V\) & \(\int{\p{V ∪ Uᶜ}}\)
  \end{tabularx}
  
  \caption{Slovar za logiko odprtih množic}
  \label{tab:logic-opens-dict}
\end{table}
Na očiten način logiki dodamo tudi \(⇔\) kot konjunkcijo implikacij.

V nadaljevanju bomo raje pisali logične simbole, razen kjer govorimo konkretno o
operacijah na točkah prostora. Glavni razlog za to je, da se želimo zanašati na
intuicijo iz logike, kar bo pomagalo pri razumevanju motivacije večine
definicij. Imamo pa še skrivni razlog za to, ki ga bomo razkrili kasneje.
To tudi pomeni, da bomo namesto \(⊆\) pisali \(≤\).

\begin{opomba}
  Ker je \(W∧U ≤ V\) natanko tedaj ko je \(W ≤ U⇒V\), je \(U ≤ V\) natanko
  tedaj, ko velja \(⊤ = U⇒V\), torej ko je \(U⇒V\) ``res''. To pa pomeni, da
  lahko na \(U ≤ V\) gledamo kot ``iz \(U\) sledi \(V\)''.
\end{opomba}

S tem smo vsakemu prostoru priredili izjavni račun, sedaj bi pa želeli
to logiko obogatiti do logike prvega (in nato višjega) reda.
Do neke mere lahko tudi povemo, kaj so kvantifikatorji v tej logiki, le da lahko
kvantificiramo zgolj po resničnostnih vrednostih.
Naj bo \(P\) predikat na \(𝒪X\). Izkaže se, da lahko te interpretiramo kot
funkcije tipa \(𝒪X → 𝒪X\).
Najprej, če želimo najti, na kateri množici je \(P\) res za vse \(U ∈ 𝒪X\),
moramo najti največjo odprto množico, ki je vsebovana v vsakem \(P(U)\), kar je
natanko notranjost preseka teh množic.
Obstoj je malo bolj kompliciran. Vrnimo se nazaj na primer, kjer so resničnostne
vrednosti pozitivnost realnih funkcij. Potem bi ``obstaja \(f\), da je
\(f > 0\) in velja \(P(f)\)'' lahko interpretirali kot da iščemo pozitivno funkcijo
\(f\), za katero velja \(P\). Ampak bolj skladno z razpravo zgoraj bi bilo, da
iščemo največjo odprto množico, na kateri kak tak \(f\) zadošča \(P(f)\).
Največja odprta množica je pa kar unija vseh odprtih, kjer to velja, in to
gotovo velja na vsakem \(P(f)\). Sledi, da je vrednost tega obstoja natanko unija
\(P(f)\). To se potem tudi sklada z intuicijo, da je eksistenčni kvantifikator
nekakšna neskončna disjunkcija, saj smo tudi to interpretirali kot unijo.
V splošnem sta pravili interpretacije univerzalnih kvantifikatorjev torej sledeči.
\begin{align*}
  \for{p : Ω}{P(p)}   &≔ \int{\parens[\bigg]{⋂_{U ∈ 𝒪X}P(U)}}\\
  \exist{p : Ω}{P(p)} &≔ ⋃_{U ∈ 𝒪X}P(U)
\end{align*}
Nekaj primerov formul, ki uporabljajo kvantifikatorje bi bili na primer
\(\for{p:Ω}{p∨¬p}\) ali \(\for{p:Ω}{\exist{q:Ω}{p ⇔ ¬q}}\). Prva je recimo
princip izključene tretje možnosti, druga pa nima posebnega imena, a pravi, da
je vsaka resničnostna vrednost negacija. Izkaže se, da čeprav ti formuli
konstruktivno \emph{nista} ekvivalentni, karakterizirata enake topološke
prostore. Dokaz tega dejstva se nahaja v~\cite[izr.~2.1]{GJ08}
% Zares bi lahko rekli tudi malo več. Če je \(A\) poljubna množica in \(P\)
% podobno kot zgoraj tipa \(A → 𝒪X\), lahko definiramo \(\for{a : \c A}{P(a)}\)
% kot \(\int{\p{⋂_{a ∈ A}P(a)}}\). Tu v bistvu množico \(A\) v našo logiko vložimo
% kot diskreten prostor (označen \(\c A\)), kar dela dobro za na primer množico
% naravnih števil, se pa izkaže, da za recimo realna števila ne deluje. Res,
% realna števila (v večini logik) ne bodo diskreten prostor! Si bomo pa vseeno
% podrobneje pogledali kdaj točno so, saj se izkaže, da ima to zanimive posledice.

\begin{lema}
  Za \(U ∈ 𝒪X\) velja \(X = U∨¬U\), natanko tedaj, ko je \(U\) zaprta.
\end{lema}
\begin{dokaz}
  Interpretacija \(U∨¬U\) je \(U ∪ \int{Uᶜ}\). Če je \(U\) zaprta, je
  \(¬U = Uᶜ\) in je \(U∨¬U = X\). Obratno, ker je \(U ⊥ ¬U\), če je
  \(X = U∨¬U\), mora biti \(¬U=Uᶜ\), in je \(U\) zaprta.
\end{dokaz}

\begin{trditev}\label{th:lem-is-discrete}
  Nad topološkim prostorom velja princip izključene tretje možnosti natanko
  tedaj, ko je prostor diskreten.
\end{trditev}
\begin{dokaz}
  Princip izključene tretje možnosti pravi, da velja formula
  \(\for{p : Ω}{p ∨ ¬p}\). Po gornji lemi to pomeni, da je vsaka odprta množica
  zaprta. 

  Naj bo \(t ∈ X\) in \(s ∈ \cl\{t\}⧵\{t\}\). Potem po \(T₀\) lastnosti obstaja
  odprta množica, ki ju ločuje. Ampak ker je \(s\) v zaprtju \(t\) mora biti ta
  odprta množica okolica \(t\). Ta je po predpostavki potem zaprta, torej vsebuje
  \(\cl\{t\}\). Ampak to je protislovno, saj ne sme vsebovati točke \(s\).
  Sledi, da taka točka \(s\) ne obstaja, torej je \(\cl\{t\} = \{t\}\), in je po
  prepostavki prostor diskreten.
\end{dokaz}

\begin{definicija}
  Prostor je \emph{ekstremalno nepovezan}, ko je zaprtje vsake odprte množice
  odprto.
\end{definicija}
\begin{trditev}\label{th:wlem-is-ext-disc}
  Nad topološkim prostorom velja DeMorganov zakon natanko tedaj, ko je prostor
  ekstremalno nepovezan.
\end{trditev}
\begin{dokaz}
  DeMorganov zakon je ekvivalenten trditvi \(\for{p : Ω}{¬p ∨ ¬¬p}\), kar pa
  po gornji lemi pravi, da so vse zunanjosti množic zaprte. To pa pomeni, da so
  njihovi komplementi, torej zaprtja množic odprta, kar je natanko kar smo
  želeli.
\end{dokaz}
Žal za te prostore tudi če predpostavimo, da je prostor \(T₀\), nimamo boljše
karakterizacije.


\subsection{Heytingovo vrednotene množice}\label{sec:modeli-heyting}

Oglejmo si spet primer naravnih števil nad nekim prostorom \(X\). To bodo zvezne
preslikave iz odprtih podmnožic \(X\) v \(ℕ\). Najprej lahko vsaki taki
preslikavi dodelimo ``resničnostno vrednost obstoja'', oziroma \emph{razpon}, ki
bo kar njena domena. To označimo z \(‖-‖\). Če je \(n : U → ℕ\), potem \(n\)
obstaja zgolj na \(U\), saj izven \(U\) nima vrednosti. Različni taki naravni
števili lahko tudi primerjamo, tako da preprosto pogledamo množico, na kateri
sta enaki: \(⟦n = m⟧ = \set{t ∈ \e n ∩ \e m}{n(t) = m(t)}\), kjer seveda pazimo,
da \(t\) jemljemo zgolj iz razpona obeh števil. Načeloma bi morali vzeti
notranjost te množice, saj morajo biti resničnostne vrednosti odprte, ampak v
tem primeru, ker so funkcije lokalno konstantne, bo ta množica odprta. Potem pa
se izkaže, da velja enakost \(⟦n = n⟧ = \e n\), tako da če znamo primerjati
vsa števila, lahko izpeljemo tudi razpon, kar bomo tudi vzeli kot osnovni
gradnik naših objektov.

Kot omenjeno zgoraj, se topološke modele konstruira iz okolišev, tako da bomo to
na skrivaj storili tudi mi. Topologija vsakega topološkega prostora je namreč
okoliš, tako da izvedimo konstrukcijo za polno Heytingovo algebro \(ℒ\), ki si
lahko mislimo, da je enaka \(𝒪X\).
\begin{definicija}\label{def:ℒset}
  \emph{Heytingovo vrednotena množica} oziroma \emph{tip} je množica \(A\),
  skupaj s preslikavo, ki jo pišemo \(⟦- = -⟧ : A×A → ℒ\), tako da velja
  \begin{align*}
    ⟦ a = b ⟧ ≤ ⟦ b = a ⟧\\
    ⟦ a = b ⟧ ∧ ⟦ b = c ⟧ ≤ ⟦ a = c ⟧
  \end{align*}
  Če iz konteksta ni razvidno kateri množici pripada preslikava \(⟦- = -⟧\),
  jo pišemo z indeksom \(⟦- =_A -⟧\). Prav tako bomo po potrebi množici \(A\)
  pravili \emph{množica elementov (tipa A)}.

  Kot zgoraj naj bo \(‖a‖ ≔ ⟦a = a⟧\) \emph{razpon \(a\)}.
\end{definicija}

Če \(≤\) beremo kot logično implikacijo, zgornja aksioma zgledata zelo podobno
aksiomoma simetričnosti in tranzitivnosti relacije \(=\), tako da bi lahko
rekli, da so tipi natanko množice opremljene z (interno) delno ekvivalenčno
relacijo.

\begin{primer}
  Na \(\set{f : U → ℕ}{U ∈ ℒ\text{, }f\text{ lokalno konstantna}}\) lahko
  definiramo enakost
  \[ ⟦n = m⟧ = \set{t ∈ X}{n(t) = m(t)}\text. \]
  To je tip, ki ga bomo označili z \(𝒩\).
\end{primer}

\begin{primer}\label{ex:reals}
  Na \(\set{f : U → ℝ}{U ∈ ℒ\text{, }f\text{ zvezna}}\) lahko definiramo enakost
  \[ ⟦f = g⟧ = \int{\p{\set{t ∈ X}{f(t) = g(t)}}}\text. \]
  To je tip, ki ga bomo označili z \(ℛ\).
  %, oziroma z \(ℝ_d\), saj se
  %izkaže, da je to objekt dedekindovih realnih števil v internem svetu.
\end{primer}

Gornja dva primera sta primera bolj splošne konstrukcije, saj so zvezne
preslikave v \(ℕ\) lokalno konstantne (in lokalno konstantne so očitno zvezne).
Tej konstrukciji v splošnem pravimo \emph{snop lokalnih prerezov}. Specifično so
njeni elementi lokalni prerezi preslikave \(π : X×A → X\). Ta konstrukcija dela
le za topološke prostore, in je naravni način kako topološki prostor \(A\)
``internalizirati''. Je pa vredno omeniti, da lahko vsakemu tipu priredimo
priredimo tak topološki prostor, da bo snop lokalnih prerezov izomorfen
začetnemu tipi. Detajle o tem si lahko ogledate v~\cite[pogl.~2]{MM92}, kjer
izvedejo konstrukcijo prostora, in~\cite[pogl.~4]{FS79}
ali~\cite[pogl.~2.6-2.8]{Borceux94}, kjer pokažejo ekvivalenco med Heytingovo
vrednotenimi množicami in snopi, kot so definirani v prvem viru.

Struktura Heytingovo vrednotenih množic pa zajema več kot le snope lokalnih
prerezov.

\begin{konstrukcija}
  Množica \(∅\) je tip. Množica \(\{*\}\) z enakostjo \(\i{*=*} = X\) je tip, ki
  ga označimo z \(\bb 1\). Pravimo jima \emph{prazen tip} in \emph{tip z enim
    elementom}.
\end{konstrukcija}
\begin{dokaz}
  Očitno je enakost na \(\{*\}\) simetrična in tranzitivna. Prav tako ima
  množica \(∅\) za enakost prazno preslikavo, ki na prazno zadošča pogojema.
\end{dokaz}

\begin{primer}
  Množica \(ℕ\) skupaj z enakostjo definirano kot
  \[ ⟦n = m⟧ ≔
    \begin{cases}
      X &; n = m\\
      ∅ &; n ≠ m
    \end{cases}
  \]
  je tip, ki ga bomo označevali z \(\c ℕ\).
\end{primer}

Ti primeri so primeri bolj splošne konstrukcije imenovane \emph{konstantni tipi}.
\begin{konstrukcija}\label{def:constant-hvs}
  Naj bo \(A\) množica in enakost na njej definirana kot zgoraj, torej
  \(\i{a = b} ≔ ⋃\set{X}{a = b}\). To je tip, ki ga označimo \(\c A\).
\end{konstrukcija}
\begin{dokaz}
  Množica \(\i{a = b}\) bo \(X\) natanko tedaj, ko je \(\i{b = a} = X\), tako da
  je enakost simetrična.

  Če je \(\i{a = b} ∧ \i{b = c} = X\), vemo, da je \(a = b = c\), torej je
  \(\i{a = c} = X\). Če pa je ta presek prazen, bo pa gotovo manjši od česarkoli
  na desni strani.
\end{dokaz}
Ko ne bo dvoumno bomo podčrtaj na konstantnih tipih opuščali.

Te nam služijo kot vložitve navadnih množic v notranji svet topološkega modela.
Najbolj prav to pride, ko imamo družino elementov tipa, in jo želimo smatrati
kot družino tudi znotraj modela.

Poznamo pa tudi primere, ki pa ne spadajo v gornje kategorije.
\begin{primer}
  Množica \(ℒ\) skupaj z enakostjo \(\i{p = q} ≔ p ⇔ q\) je tip. Označimo ga z
  \(Ω\), saj so njeni elementi natanko resničnostne vrednosti naše logike.
\end{primer}

Ampak naša motivacija za definicijo Heytingovo vrednotenih množic so bile ravno
množice zveznih preslikav, kar te niso.
To je zato, ker imajo zvezne funkcije še dve pomembni lastnosti, ki jih v
strukturi sami ne zajamemo.
Prvič, funkcije lahko zožamo. To preprosto pomeni, da če vrednost obstaja na
neki odprti množici, potem obstaja tudi na vsaki manjši odprti množici.
Drugič, če imamo družino zveznih funkcij, ki se paroma ujemajo na presekih
njihovih domen, jih lahko enolično zlepimo v zvezno funkcijo, definirano na
uniji njihovih domen. V primeru zveznih funkcij v naravna števila je ta lastnost
zelo zanimiva, saj je vsaka lokalno konstantna funkcija tak zlepek konstantnih
funkcij. Potem pa če to združimo še z zožitvami, lahko rečemo, da je vsaka
funkcija \(U → ℕ\) zlepek zožitev konstantnih funkcij \(X → ℕ\).
Tako lahko na nek način rečemo, da so zvezne funkcije v naravna števila
``generirane'' z množico naravnih števil samo.
To pa zares pomeni, da je \(𝒩\) nekakšna \emph{napolnitev} tipa \(\c ℕ\).

Torej ne bomo zahtevali, da so naši objekti zaprti za zožitve in lepljenje, saj
jih lahko vedno napolnimo. Izkaže pa se, da nam to ustvari nekaj težav pri
definiciji funkcij.
Želeli bi, da bi preslikave zadoščale dvem pogojem. Prvič, upali bi, da nekako
spoštujejo enakosti na tipih, torej da velja \(\i{a=a'} ≤ \i{f(a) = f(a')}\).
Poleg tega pa, bi pričakovali, da če \(a\) obstaja, bi obstajal tudi \(f(a)\),
oziroma da velja \(\e a ≤ \e{f(a)}\). Izkaže pa se, da to ne bo zajelo vseh
možnih preslikav, ki bi jih želeli definirati.

\begin{primer}\label{ex:one-to-one}
  Naj bo \(\p{2, 𝒫2}\) diskreten prostor na dveh točkah.
  Tip \(A\) naj ima dva elementa, \(a₀\) in \(a₁\), definirana v vsaki od točk
  prostora. Prvi problem je, da tip \(A\) sploh nima elementa, ki bi obstajal na
  celem prostoru. A vendar lahko definramo relacijo \(R(*,aᵢ)≔\{i\}\), ki se
  izkaže da je funkcijska na primeren način. Ta se obnaša, kot da slika \(*\) na
  \(0\) v \(a₀\) in na \(1\) v \(a₁\). Ampak očitno taka preslikava ne obstaja
  kot funkcija \(\bb 1 → A\).
\end{primer}

To nam da idejo, da lahko preslikave definiramo kot funkcijske relacije, seveda
spet vrednostene v logiki odprtih množic.

Definirajmo najprej, kaj pomeni, da je neka presliakva z vrednostmi v \(ℒ\)
relacija. Prav tako definirajmo kaj pomeni, da je preslikava med tipi operacija.
Te porodijo poseben primer morfizmov, ki pa dejansko so funkcije med množicami
elementov.
\begin{definicija}
  Preslikava \(R : A₁×\dots×Aₙ → ℒ\) je \emph{relacija na \(A₁×\dots×Aₙ\)}, ko
  velja
  \begin{align*}
    \i{a₁ = a₁'} ∧ \dots ∧ \i{aₙ = aₙ'} ∧ R(a₁,…,aₙ) ≤ R(a₁',…,aₙ')\text{ in}\\
    R(a₁,…,aₙ) ≤ \e{a₁}∧\dots∧\e{aₙ}\text.
  \end{align*}
  Relacijam na \(A×B\) bomo pravili tudi \emph{relacije med \(A\) in \(B\)}.

  Preslikava \(f : A₁×\dots×Aₙ → B\) je \emph{operacija tipa \(A₁×\dots×Aₙ → B\)},
  ko velja 
  \begin{align*}
    \i{a₁ = a₁'} ∧ \dots ∧ \i{aₙ = aₙ'} ≤ f(a₁,…,aₙ) = f(a₁',…,aₙ')\text{ in}\\
    f(a₁,…,aₙ) ≤ \e{a₁}∧\dots∧\e{aₙ}\text.
  \end{align*}
  Pišimo \(f : A₁×\dots×Aₙ ↝ B\).
\end{definicija}

\begin{definicija}\label{def:ℒmap}
  \emph{Morfizem} med tipoma \(A\) in \(B\) je relacija \(f\) med \(A\) in
  \(B\), za katero velja
  \begin{align}
    &f(a,b) ∧ f(a,b') ≤ \i{b =_B b'} \tag{enoličnost}\label{eq:enoličnost-raw}\\
    &\e a ≤ ⋁_{b ∈ B} f(a,b)         \tag{celovitost}\label{eq:celovitost-raw}
  \end{align}

  Ker so morfizmi torej funkcijske relacije, jih bomo pisali v funkcijskem
  zapisu kot \(f : A ↬ B\).
\end{definicija}
Vseeno pa bomo internem jeziku na \(⋁_{b ∈ B} φ(b)\) gledali kot eksistenčni
kvantifikator, torej celovitost res pravi, da obstaja nek \(b\), ki je slika
elementa \(a\). To nam bo kasneje omogočilo, da na morfizme gledamo kot
operacije. Ampak, ne prenaglimo se, povejmo najprej točno, kaj ta interni jezik
sploh je.


\subsubsection{Interni jezik}

Uvedimo oznako za interpretacijo logičnih formul kot odprte množice, t.~j.~za
formulo \(φ\) označimo njeno interpretacijo kot \(⟦φ⟧\). Ta je namerno enaka
enakosti, saj bomo enakosti v internem jeziku intepretirali kot enakosti na
Heytingovo vrednotenih množicah. Kot lahko sklepate, bomo v to logiko dodali
Heytingovo vrednotene množice kot \emph{tipe}. Definirajmo najprej, kaj pomeni,
da je v internem jeziku nek izraz \emph{term} tipa \(A\).
% Spomnimo se sedaj tabele za logiko odprtih množic, z novim zapisom:
% \begin{center}
%   \begin{tabularx}{0.6\textwidth}{p{0.2\textwidth}|X}
%     \(⟦⊤⟧\)     & \(≔ X\)\\
%     \(⟦⊥⟧\)     & \(≔ ∅\)\\
%     \(⟦U ∧ V⟧\) & \(≔ U ∩ V\)\\
%     \(⟦U ∨ V⟧\) & \(≔ U ∪ V\)\\
%     \(⟦¬U⟧\)    & \(≔ \ext{U}\)\\
%     \(⟦U ⇒ V⟧\) & \(≔ \int{\p{V ∪ Uᶜ}}\)
%   \end{tabularx}
% \end{center}
% Torej, vse je enako kot prej, ampak sedaj lahko našemu jeziku dodamo še
% Heytingovo vrednotene množice. Najprej, interpretirajmo terme jezika.

Nek izraz je term tipa \(A\), ko ga lahko \emph{skonstruiramo} na enega od
sledečih načinov. Najosnovnejši način je, da vzamemo kar dobesedne elemente tipa
\(A\). Če imamo operacijo tipa \(B → A\), jo lahko uporabimo na nekem obstoječem
termu tipa \(B\), da dobimo term tipa \(A\). Poleg tega pa se v izrazih lahko
pojavljajo spremenljivke, recimo v kvantificiranih izrazih. Te interpretiramo
kot spremenljivke istega tipa v zunanjem svetu. Zares bi lahko v jezik uvedli
polnomočen \(λ\) račun, a to ni potrebno.
% TODO: to bi loh nardil, ampak rabim like, enkrat.
% Ker je naš jezik zelo osnoven, bo to
% vse, bomo pa kasneje uvedli polnomočen \(λ\) račun, kar nam bo olajšalo delo z
% jezikom.

Naj \(τ : A\) pomeni ``term \(τ\) je tipa \(A\)'' in za \(τ : A\) induktivno
definiramo \(\i τ_A\) kot element (ali izraz s prosto spremenljivko) tipa \(A\),
glede na tabelo~\ref{tab:int-term}.

\begin{table}[h]
  \centering
  \begin{align*}
    &\i a_A ≔ a \text{, za \(a ∈ A\)}\\
    &\i x_A ≔ x \text{, za spremenljivko \(x\) tipa \(A\)}\\
    &\i{f(β)}_A ≔ f{\p{\i β_B}} \text{, za operacijo \(f : B → A\) in \(β : B\)}
  \end{align*}

  \caption{Interpretacija termov v internem jeziku}
  \label{tab:int-term}
\end{table}

Prav tako induktivno definiramo interpretacijo formul s \(\i -\).

\begin{table}[h]
  \centering
  \begin{tabularx}{0.8\textwidth}{p{0.2\textwidth}|c}
    Interna logika          & Topologija\\
    \hline
    \(⊤\)                   & \(X\)\\
    \(⊥\)                   & \(∅\)\\
    \(φ ∧ ψ\)               & \(\i φ ∩ \i ψ\)\\
    \(φ ∨ ψ\)               & \(\i φ ∪ \i ψ\)\\
    \(¬φ\)                  & \(\ext{\i φ}\)\\
    \(φ ⇒ ψ\)               & \(\int{\p{\i ψ ∪ {\i φ}ᶜ}}\)\\
    \(\for{x : A}{φ(x)}\)   & \(\int{\p{⋂_{a ∈ A}\i{\e a ⇒ φ(a)}}}\)\\
    \(\exist{x : A}{φ(x)}\) & \(⋃_{a ∈ A}\i{\e a ∧ φ(a)}\)\\
    \(τ = σ\)               & \(\i{\i τ_A = \i σ_A}\)\\
    %\(\i{\e τ}\)                & \(≔ \e{\i τ}\)\\
    %\(\i{τ \sim f(σ)}\)         & \(≔ \i{\i τ \sim f(\i σ)}\)\\
    \(R(τ)\)                & \(R{\p{\i τ_A}}\), kjer je \(R\) relacija na \(A\)
  \end{tabularx}

  \caption{Interpretacija formul v internem jeziku}
  \label{tab:int-sent}
\end{table}
\begin{opomba}
  Vsi morfizmi so relacije torej jih v interni jezik dodamo kot relacijske
  simbole. Prav tako je \(\e -\) relacija, saj velja
  \(\i{a = a'}∧\e{a'} ≤ \e a\) in \(\e a ≤ \e a\), tako da tudi to dodamo kot
  relacijski simbol.
\end{opomba}
\begin{opomba}    
  Vredno je tudi omeniti, da so enakosti Heytingovo vrednotenih množic tudi
  relacije, in da je njihova interpretacija kot enakost in kot relacija enaka.
\end{opomba}

\begin{definicija}\label{def:valid}
  Formula \(φ\) brez prostih spremenljivk je \emph{veljavna na \(U\)} (pišemo
  \(U ⊩ φ\)), ko je \(\i φ ≥ U\).

  Formula \(φ\) je \emph{veljavna} ko je veljavna na \(X\), in to bomo pisali
  tudi kot \(⊩ φ\).
\end{definicija}

\begin{trditev}\label{th:valid-res}
  Veljavnost lakho zožimo, torej če velja \(U ⊩ φ\) in je \(V ⊆ U\), velja tudi
  \(V ⊩ φ\).
\end{trditev}
\begin{dokaz}
  Po definiciji \(V ⊆ U ⊆ \i φ\).
\end{dokaz}

\begin{trditev}\label{th:valid-glue}
  Veljavnost lahko lepimo, torej če je \(C\) pokritje \(U\), in za vsak
  \(V ∈ C\) velja \(V ⊩ φ\), velja tudi \(U ⊩ φ\).
\end{trditev}
\begin{dokaz}
  Če za vsak \(V ∈ C\) velja \(V ⊆ \i φ\), bo \(\i φ\) večji tudi od njihove
  unije, kar je pa natanko \(U\).
\end{dokaz}
To nam da zanimivo posledico, da je veljavnost ekvivalentna lokalni veljavnosti.
\begin{definicija}
  Zunanji predikat \(P : ℒ → \{⊤,⊥\}\) je na \(U\) \emph{lokalno ali sčasoma res}
  (pišemo \(\eventually{V ⊆ U}{P(V)}\)), ko obstaja pokritje \(C\) množice
  \(U\), tako da za vsak element pokritja velja \(P(V)\).
\end{definicija}
Tukaj bo bil \(P(V)\) najpogosteje oblike \(\exist{a∈A}{V ⊩ \e a ∧ φ(a)}\).
V tem primeru bomo v naravnem jeziku pravili ``sčasoma na V obstaja…''.

Ampak za \(P(V) ≔ V ⊩ φ\) nam pa gornji pojem povzame trditvi~\ref{th:valid-res}
in~\ref{th:valid-glue}.
\begin{posledica}\label{th:valid-local}
  \(U ⊩ φ\) natanko tedaj ko \(\eventually{V ⊆ U}{V ⊩ φ}\).
\end{posledica}

\begin{trditev}
  Veljavnost formule se lahko računa po tabeli~\ref{tab:kj-sem}.
  \begin{table}[h]
    \centering
    \begin{tabularx}{0.9\textwidth}{p{0.25\textwidth}X}
      \(U ⊩ ⊤\)                   & vedno\\
      \(U ⊩ ⊥\)                   & ko je \(U = ∅\)\\
      \(U ⊩ φ ∧ ψ\)               & ko \(U ⊩ φ\) in \(U ⊩ ψ\)\\
      \(U ⊩ φ ∨ ψ\)               & ko
                                    \(\eventually{V ⊆ U}{V ⊩ φ\text{ ali }V ⊩ ψ}\)\\ 
      \(U ⊩ φ ⇒ ψ\)               & ko za vsak \(V ∈ 𝒪U\) velja, da iz \(V ⊩ φ\)
                                    sledi \(V ⊩ ψ\)\newline
                                    ali ko velja \(U∩\i φ ⊩ ψ\)\\
      \(U ⊩ ¬φ\)                  & ko za vsak \(V ∈ 𝒪U\) velja, da iz \(V ⊩ φ\)
                                    sledi \(V = ∅\)\newline
                                    ali ko velja \(U ⊥ \i φ\)\\
      \(U ⊩ \for{x : A}{φ(x)}\)   & ko za vsak \(a ∈ A\) velja \(U ∩ \e a ⊩ φ(a)\)\\
      \(U ⊩ \exist{x : A}{φ(x)}\) & ko \(\eventually{V ⊆ U}{\exist{a ∈ A}{V ⊆ \e a
                                    \text{ in } V ⊩ φ(a) }}\)
    \end{tabularx}

    \caption{Veljavnost formul oziroma Kripke-Joyalova semantika}
    \label{tab:kj-sem}
  \end{table}
\end{trditev}
\begin{dokaz}
  Večina točk zgoraj je očitna, tako da se osredotočimo zgolj na disjunkcijo in
  obstoj.
  
  Pri disjunkciji po definiciji \(U ⊩ φ ∨ ψ\) velja, ko je \(U ≤ \i φ ∪ \i ψ\), torej, ko
  \(\i φ\) in \(\i ψ\) pokrivata prostor. Ampak, očitno velja \(\i φ ⊩ φ\) in
  \(\i ψ ⊩ ψ\), torej obstaja želeno pokritje.
  Obratno pa, če vzamemo vse elemente pokritja, na katerih velja \(φ\), bo \(φ\)
  veljal tudi na njihovi uniji, tako da če tako pokritje obstaja, bi ga vedno lahko
  zamenjali s pokritjem \(\{\i φ, \i ψ\}\).

  Situacija z obstojem je popolnoma analogna, saj pogoj na desni pravi natanko,
  da množice \(\i{\e a ∧ φ(a)}\) pokrivajo \(U\).
\end{dokaz}
\begin{opomba}
  Pri implikaciji imamo dva načina, kako jo dokazati. Izkaže se, da je v
  različnih primerih lažje uporabiti različne načine. Ponavadi, če sta izraza
  \(φ\) in \(ψ\) dokaj preprosta, bo drugi način boljši, ampak če prevajamo kak
  zahtevnejši izraz, je pa bolj praktično interpretirati implikacijo kot kar
  implikacijo, in stvari poenostaviti kasneje.
\end{opomba}

Ker želimo v internem jeziku pisati matematiko, bi bilo dobro, da lahko v njem
dejansko sklepamo.
\begin{izrek}[Zdravost]
  Če je formula \(φ\) konstruktivno formalno dokazljiva, je tudi veljavna v naši
  logiki.
\end{izrek}

Dokaza tu ne navedemo, da se ognemo 20 stranem točne definicije ``formalno
dokazljiva'', si pa to lahko ogledate v~\cite{Scott79,FS79}. Dokaz poteka dokaj
rutinsko, preveriti je zgolj treba, da so interpretacije vseh aksiomov veljavne.
Na primer za univerzalni kvantifikator mora veljati
\(\p{\for{x:A}{φ(x)}}∧\e t ⇒ φ(t)\). Za vajo lahko preverite, da se res
interpretira v \(⊤\).

% Pri disjunkciji pa dejansko dobimo nekaj več. Če je \(φ∨ψ\) konstruktivno res,
% je res kar že en od disjunktov (recimo \(φ\)). Potem pa po indukciji velja
% \(X ⊩ φ\), torej \(φ\) je res na celotnem \(X\), kar je močneje od
% interpretacije \(φ∨ψ\) v naši logiki. To je posledica dejstva, da je
% konstruktivna resnica močnejša od resnice v naših modelih, kajti topološki
% modeli niso vsi možni modeli konstruktivne logike.

Ponovimo sedaj gornje definicije v internem jeziku.
\begin{redefinicija}{def:ℒset}
  \emph{Tip \(A\)} je množica \(A\) z relacijo \(=\) na \(A×A\), za katero velja
  \begin{align*}
    &⊩ \for{x,y:A}{x = y ⇒ y = x}\text{ in}\\
    &⊩ \for{x,y,z:A}{x = y ∧ y = z ⇒ x = z}\text.
  \end{align*}
\end{redefinicija}
Zares tu ne moremo govoriti o relaciji na množici, dokler ta ni tip. Ampak ta
definicija služi zgolj za ilustracijo, tako da to ni problematično. Definicijo
morfizmov pa lahko brez problema napišemo v tem stilu.

\begin{redefinicija}{def:ℒmap}
  \emph{Morfizem med tipoma \(A\) in \(B\)} je relacija \(f\) med \(A\) in
  \(B\), za katero veljata
  \begin{align}
    &⊩ \for{x:A}{\for{y,y':B}{f(x,y)∧f(x,y') ⇒ y=y'}} \tag{enoličnost}\label{eq:enoličnost}\\
    &⊩ \for{x : A}{\exist{y : B}{f(x,y)}}             \tag{celovitost}\label{eq:celovitost}
  \end{align}
\end{redefinicija}
\begin{opomba}
  Pogoja enoličnosti in celovitosti lahko sedaj združimo v en pogoj
  \[ \for{x:A}{\unique{y:B}{f(x,y)}}\text. \]
  Res, drugi pogoj nam pove, da tak \(y\) obstaja, medtem ko nam prvi pogoj
  pove, da je tak \(y\) enoličen.
\end{opomba}


\subsubsection{Relacije in podobjekti}

Z notranjim jezikom si lahko pomagamo pri konstruiranju relacij. Natančno to
pomeni, da bomo formule s prostimi spremenljivkami interpretirali kot
preslikave, ki pa bodo avtomatsko zadoščale pravilom relacij.

Najprej si olajšajmo delo, in definirajmo produkte tipov. Potem bomo lahko vse
definirali za eno spremenljivko, saj lahko relacije na več spremenljivkah
predstavimo kot eniško relacijo (ozioma predikat) na produktu.

\begin{konstrukcija}\label{cons:prod}
  Naj bosta \(A\) in \(B\) tipa. Njun produkt je množica
  \[ \set{(a, b) ∈ A×B}{\e a = \e b}, \]
  enakost pa definiramo po točkah
  \[ \i{\p{a, b} = \p{a', b'}} ≔ \i{a = a'} ∧ \i{b = b'}\text. \]
\end{konstrukcija}
\begin{dokaz}
  Gornja enakost je očitno simetrična in tranzitivna, tako da tvori
  tip.
\end{dokaz}
\begin{opomba}
  Zgoraj za nosilec produkta vzamemo pare, ki so enako definirani. To storimo
  zato, da bomo kasneje lahko definirali ustrezne projekcije iz produkta, saj
  sicer te nebi bile morfizmi.
\end{opomba}

\begin{konstrukcija}\label{cons:rel-from-formula}
  Naj bo \(φ\) formula s prosto spremenljivko \(x\) tipa \(A\). Potem preslikava
  \(a ↦ \e a ∧ \i{φ(a)}\) definira relacijo na \(A\).
\end{konstrukcija}
\begin{dokaz}
  Označimo to preslikavo s \(\hat φ\).
  Preslikava je očitno stroga. Prav tako je ekstenzionalna, saj velja
  \begin{align*}
    \i{a = a'} ∧ \hat φ(a')
    &≤ \i{a = a'} ∧ \e{a'} ∧ \i{φ(a')}\\
    &≤ \e a ∧ \i{a = a' ∧ φ(a')}\\
    &≤ \e a ∧ \i{φ(a)} = \hat φ(a)\text.\qedhere
  \end{align*}
\end{dokaz}
\begin{opomba}
  Če je formula \(φ\) že taka, da velja \(\i{φ(a)} ≤ \e a\) za vse \(a ∈ A\),
  lahko preprosto pišemo \(\hat φ(a) ≔ \i{φ(a)}\).
\end{opomba}

\begin{primer}
  Če je \(R\) relacija na \(A\), je \(\hat R = R\). Res, ker je \(R\) že sama po
  sebi stroga, lahko uporabimo gornjo opombo in pišemo \(\hat R(a) = \i{R(a)}\).
  Ampak to je pa natanko \(R(a)\).
\end{primer}
\begin{primer}
  Naj bo \(x ≡ y \mod 2\) formula s prostima spremenljivkama tipa \(\c ℕ\). Potem
  ta definira relacijo, ki je simetrična in tranzitivna, torej definira tip.
  Njegova množica elementov je neskončna, a je izomorfen tipu \(\c 2\).
\end{primer}
Na ta način lahko torej definramo izpeljane tipe. Je pa to najbolj uporabno pri
definiciji morfizmov.

\begin{konstrukcija}
  Če imamo morfizma \(A \oset{f}{↬} B \oset{g}{↬} C\), je njun kompozitum
  \({g∘f : A ↬ C}\) definiran z relacijo
  \[ \exist{y : B}{f(x,y) ∧ g(y,z)}\text. \]
\end{konstrukcija}
\begin{dokaz}
  Kompozitum funckijskih relacij je konstruktivno spet funkcijska relacija, tako
  da je res morfizem.
\end{dokaz}

\begin{konstrukcija}
  Identiteta na \(A\) je kar \(⟦- =_A -⟧\).
\end{konstrukcija}
\begin{dokaz}
  Znotraj je enakost na \(A\) identitetna relacija, torej je enota za
  kompozitum.
\end{dokaz}

\begin{definicija}
  Kategorijo tipov z morfizmi in gornjim kompozitumom in identiteto označimo z
  \(\cat{Set}(ℒ)\).
\end{definicija}

Oglejmo si kaj so podobjekti tipa \(A\). Običajno so te do izomorfizma
natančno monomorfizmi s kodomeno \(A\). Poleg tega so urejeni, tako da je
\(S ⊆ T\) natanko tedaj, ko obstaja monomorfizem \(S → T\). Vemo pa tudi, da
ponavadi lahko podobjekte predstavimo s \emph{predikati} na množici, torej
funkcijami iz \(A\) v množico resničnostnih vrednostih.

V našem primeru igra topologija \(ℒ\) vlogo množice resničnostnih vrednosti,
tako da bi lahko za podobjekte vzeli morfizme tipa \(A ↬ ℒ\), ampak se izkaže,
da lahko definicijo še poenostavimo.

\begin{lema}\label{th:ℒsub-is-map-to-Ω}
  Za vsak morfizem \(f : A ↬ Ω\) obstaja enolična operacija \(\hat f : A → Ω\),
  tako da je morfizem porojen z \(\hat f\) enak \(f\).
\end{lema}
\begin{dokaz}
  Definirajmo \(\hat f(a) ≔ f(a,⊤)\).
  Očitno je \(\hat f(a) ≤ \e a\), saj je vsak \(f(a,⊤) ≤ \e a\).

  Denimo sedaj, da je \(a=a'\). Potem je \(f(a,⊤) = f(a',⊤)\), torej je
  \(\hat f(a) = \hat f(a')\), torej je \(\hat f\) res operacija.

  Naj velja \(f(a,U)\). Potem je \(f(a,U) = f(a,⊤)\), torej je
  \({U = f(a,U) = \hat f(a)}\).

  Obratno, naj velja \(f(a,⊤) = U\) in denimo, da \(U\) velja. Potem pa tudi
  \(f(a,U)\) velja, po prvi lasnosti relacije.
\end{dokaz}

Torej lahko za podobjekte vzamemo kar eniške relacije na \(A\), saj so te
natanko operacije v \(Ω\). Kasneje bomo pa pokazali, da so to res podobjekti.

\begin{definicija}\label{def:subset}
  Eniškim relacijam na \(A\) pravimo \emph{podtipi \(A\)} in označimo \(S ⊑ A\).
  Za \(τ : A\) in \(S ⊑ A\) bomo namesto \(S(τ)\) pisali \(τ ∈ S\). Interni
  jezik razširimo z \(∈\) na očiten način.
\end{definicija}

\begin{konstrukcija}\label{cons:ℒ-sub-lattice}
  Podtipi tvorijo delno ureditev z ureditvijo
  \[ S ⊑ T :⇔\ ⊩ \for{x : A}{x ∈ S ⇒ x ∈ T}\text. \]
\end{konstrukcija}

Definirajmo sedaj boljši zapis za konstrukcijo~\ref{cons:rel-from-formula}.
\begin{definicija}\label{notation:setbuilder}
  Naj bo \(φ\) formula s prosto spremenljivko \(x : A\). Potem relacija
  \[ a ↦ \e a ∧ \i{φ(a)} \]
  določa podtip \(A\), ki ga označimo z \(\set{x : A}{φ}\).
\end{definicija}

\begin{definicija}\label{notation:image}
  Vsakemu morfizmu \(f : A ↬ B\) in podtipoma \(S ⊑ A\) in \(T ⊑ B\) lahko
  priredimo
  \begin{enumerate}
  \item podtip \(f[S] ⊑ B\), definiran kot
    \(\set{y : B}{\exist{x ∈ S}{f(x,y)}}\), imenovan \emph{slika} in
  \item podtip \(f⁻¹[T] ⊑ A\), definiran kot
    \(\set{x : A}{\exist{y ∈ T}{f(x,y)}}\), imenovan \emph{praslika}. 
  \end{enumerate}
\end{definicija}

\begin{konstrukcija}\label{cons:sing}\label{notation:sing-image}
  Za \(a ∈ A\) lahko tvorimo \(\s a ≔ \set{x : A}{x = a}\). Temu podtipu
  bomo pravili \emph{enojec}.

  Za enojce lahko poenostavimo zapis za sliko in prasliko,
  \[ f[a] ≔ f[\s a] = \set{y : B}{f(a,y)} \text{ in}\]
  \[ f⁻¹[b] ≔ f⁻¹[\s b] = \set{x : A}{f(x,b)} \text,\]
  kot smo vajeni.
\end{konstrukcija}

Primer te konstrukcije smo zares že videli, v dokazu
leme~\ref{th:ℒsub-is-map-to-Ω}. Tam smo zares iz morfizma \(f : A ↬ Ω\)
skonstruirali podtip \(f⁻¹(⊤)\). Iz teorije kategorij pa vemo, da če je \(f\)
karakteristična preslikava podobjekta \(S\), je potem \(S = f⁻¹(⊤)\), torej je
to natanko ista konstrukcija. Pokažimo sedaj, da so podtipi natanko podobjekti.

Preden se lotimo dejanskega dokaza pa pokažimo, da lahko iz vsakega podtipa
zgradimo dejanski tip, ki se vloži v svoj nadtip. To je zares konstrukcija
podobjekta iz podtipa.
\begin{konstrukcija}\label{cons:ℒset-from-ℒsub}
  Naj bo \(P ⊑ A\). Tvorimo tip \(\hat P\) na množici \(A\) z enakostjo
  definirano kot \(x =_A x'∧P(x)\).
  Identiteta na \(A\) potem definira monomorfizem \(m : \hat P ↬ A\).
\end{konstrukcija}
\begin{dokaz}
  Relacija je simetrična, saj iz \(x=x'∧P(x)\) sledi \(P(x')\), in obratno.
  Tranzitivnost pa očitno sledi iz tranzitivnosti \(=_A\).

  Za morfizem \(m\) velja, da za vsak \(f : B ↬ \hat P\) velja
  \(m∘f(b,a) = f(b,a)\). To pa pomeni, da je monomorfizem, torej vložitev.
\end{dokaz}

\begin{trditev}\label{th:ℒsub-is-sub}
  Delni ureditvi podtipov \(A\) in podobjektov \(A\) sta si ekvivalentni.
\end{trditev}
\begin{dokaz}
  Naj bo \(m : S ↬ A\) monomorfizem. Temu lahko priredimo sliko \(m[S]\). Ta
  prireditev ohranja neenakost, tako da je injektivna in dobro definirana na
  množici ekvivalenčnih razredov.
  Obratno, vsakemu podtipu \(P ⊑ A\) priredimo monomorfizem \(m : \hat P ↬ A\),
  kot definiran zgoraj.
  
  Preverimo, da sta si ti operaciji inverzni.
  Če začnemo z \(m : S ↬ A\), se \(m\) zoži na \(S ↬ A/m[S]\). Prav tako je ta
  morfizem surjektiven, saj za vsak \(a : A/m[S]\) vemo, da ima razpon
  \(\e a ∧ a ∈ m[S]\), torej obstaja nek \(s : S\), da je \(m(s,a)\).
  Obratno, če je \(P ⊑ A\) je \(a ∈ \id[\hat P]\) natanko tedaj, ko velja \(a ∈ P\).
\end{dokaz}

Za konec pa definirajmo še kvocientne tipe. Najprej pokažimo 

\begin{definicija}
  Relacija \(R\) na \(A×A\) je refleksivna, ko velja \(⊩ \for{x:A}{R(x,x)}\).
\end{definicija}

\begin{lema}
  Za refleksivno relacijo \(R\) na \(A×A\) velja
  \[ ⊩ \for{x,y:A}{x = y ⇒ R(x,y)}\text. \]
\end{lema}
\begin{dokaz}
  Naj bosta \(a\) in \(b\) tipa \(A\) enaka. Potem je \(R(a,b)\) natanko
  \(R(a,a)\), kar je pa natanko refleksivnost \(R\).
\end{dokaz}

\begin{konstrukcija}\label{cons:quot}
  Naj bo \(R\) ekvivalenčna relacija na \(A×A\). Potem množica \(A\), kjer za
  enakost vzamemo \(R\), tvori tip, ki mu pravimo \emph{kvocient \(A\) po \(R\)}
  in ga označimo \(\quot A R\).

  Identiteta na \(A\) potem definira kvocientni morfizem \(q : A ↬ \quot A R\).
\end{konstrukcija}
\begin{dokaz}
  Enakost bo očitno simetrična in tranzitivna, tako da rabimo preveriti samo, da
  identiteta res definira ustrezen morfizem.

  % Najprej pokažimo, da velja \(⊩\for{x,y:A}{x = y ⇒ R(x,y)}\). Ker je preslikava
  % refleksivna, to pomeni, da velja \(⊩ \for{x:A}{R(x, x)}\). Poleg tega
  % pa, ker je relacija, imamo \(⊢ \p{a, a'} = \p{a', a'} ∧ R(a',a') ⇒ R(a,a')\).
  % Leva stran implikacije se poenostavi na \(a = a'\), ker smo na \(\e{a'}\) in
  % je \(R(a',a')\) res.

  Naj bo \(f : A ↬ B\) morfizem, za katerega velja \(R(a,a')∧f(a',b) ≤ f(a,b)\).
  Tedaj bo \(f\) tudi morfizem tipa \(\quot A R ↬ B\), torej je \(q\) res
  kvocientna reslikava.
\end{dokaz}


\subsubsection{Polni tipi}

Pogosto omenjamo, da zaradi lokalne narave naše logike in splošnosti definicije
tipov nekateri elementi ne obstajajo. Oglejmo si recimo spet
primer~\ref{ex:one-to-one}. Naj bo \(X = 2\), in
\(A = \{a₀,a₁\}\), kjer je \(\e{aᵢ} = \{i\}\).
Potem je \(f(*,aᵢ) ≔ \{i\}\) funkcijska relacija. Ker je enolična, ima torej
\(f[*]\) kvečjemu en element. Ampak ne obstaja noben element \(a ∈ A\), ki bi
zadoščal \(f[*] = \s a\), torej \(f[*]\) ni zares enojec. Takim elementom
pravimo \emph{podenojci}.

Se pa izkaže, da velja \(i ⊩ aᵢ ∈ f[*]\), torej ima \(f[*]\) nad vsako točko
element. V interni logiki torej velja \(\exist{x:A}{x∈f[*]}\). Torej iz
notranjega sveta topološkega modela ne moremo razlikovati med enojci in
podenojci (seveda, razen za prazen podenojec), tako da bomo tem vseeno pravili
\emph{enojci}. Izkaže se, da imajo enojci zelo bogato strukturo, namreč z njimi
bomo lahko tvorili zožitve in zlepke elementov tipov, kot smo želeli v začetni
motivaciji.

% Seveda pa kot prej, ni nobenega elementa v \(A\), ki bi bil povsod element \(f[*]\).
% Ker pa nam \(f[*]\) vseeno natanko predstavlja ta element, lahko gornjo
% lastnost, torej, \(ℒ\)-podmnožica z največ enim elementom, vzamemo kot nekakšno
% ``napolnitev'' \(ℒ\)-množice \(A\). Izkaže se, da nam bo to dovolilo
% neposredno izraziti zožitve in zlepke elementov.

\begin{definicija}\label{def:sing}
  \emph{Enojec} tipa \(A\) je podtip \(σ ⊑ A\), za katerega velja
  \[ ⊩ \for{x,y:A}{x ∈ σ ∧ y ∈ σ ⇒ x = y}\text. \]
\end{definicija}
\begin{opomba}
  Za enojce se ponavadi uporablja grške črke \(σ, ρ, τ,…\).
\end{opomba}
% \begin{opomba}
%   Če želimo dokazati, da je neka preslikava enojec, zadošča preveriti gornji
%   pogoj ter drugi pogoj za \(ℒ\)-podmnožice, torej \(⊩ a = b ∧ b ∈ σ ⇒ a ∈ σ\),
%   saj prvi pogoj sledi iz gornjega pogoja.
% \end{opomba}

Sedaj smo drugič defninirali besedo enojec, enkrat v
konstrukciji~\ref{cons:sing} kot konstrukcijo specifičnega podtipa, in še enkrat
zgoraj kot lastnost podtipov. Izkaže se, da to ni dvoumno, saj imajo enojci
lastnost bitja enojec, prav tako pa kot omenjeno zgoraj, iz notranjega pogleda
je vsak podtip z lastnostjo bitja enojec tudi sam enojec (čim definiramo
ustrezne tipe, da lahko to zatrdimo). Začnimo s prvim delom.
\begin{trditev}\label{th:sing-is-subsing}
  Za \(a ∈ A\) je enojec \(\s a\) res enojec v gornjem smislu.
\end{trditev}
\begin{dokaz}
  Če imamo \(x\), \(y ∈ \s a\), je po defniciji potem \(x = a = y\), torej je
  \(x=y\).
\end{dokaz}

\begin{konstrukcija}\label{cons:compl}
  Množica enojcev \(A\) z relacijo \(σ = τ ≔ \exist{x : A}{x ∈ σ ∧ x ∈ τ}\)
  tvori tip \(\g A\).
\end{konstrukcija}
\begin{dokaz}
  Gornje očitno definira relacijo, saj je definirana v internem jeziku.
  Poleg tega je očitno simetrična, tako da si poglejmo le tranzitivnost.
  Naj bo \(σ = τ\) in \(τ = ρ\), torej obstajata \(x\) in \(y\), da velja
  \(x ∈ σ ∧ x ∈ τ\) in \(y ∈ τ ∧ y ∈ ρ\). Ker je \(τ\) enojec je \(x = y\),
  torej velja \(x ∈ σ\) in \(x ∈ ρ\), kar pa po definiciji pomeni \(σ = ρ\).
\end{dokaz}

Pokažimo sedaj še drugi del gornje razprave.
\begin{trditev}\label{th:subsing-is-sing}
  Za vsak tip \(A\) velja
  \[ ⊩ \for{σ : \g A}{\exist{x : A}{x ∈ σ}}\text. \]
\end{trditev}
\begin{dokaz}
  Če razpišemo gornje dobimo \(\e σ ≤ \i{\exist{x : A}{x ∈ σ}}\). Ampak \(\e σ\)
  je pa natanko \(\exist{x : A}{x ∈ σ ∧ x ∈ σ}\), torej je neenakosti zadoščeno.
\end{dokaz}

Pokažimo nekaj koristnih lem za delo z enojci.

\begin{lema}\label{lem:singunit}
  Za \(σ ∈ \g A\) veljajo naslednje ekvivalence:
  \begin{enumerate}
  \item \(⊩ \for{x:A}{\s x = σ ⇔ x ∈ σ}\)
  \item \(⊩ \for{x,y:A}{\s x = \s y ⇔ x = y}\)
  %\item \(⊩ \for{x,y:A}{x = y ⇔ \exist{σ : \g A}{x ∈ σ ∧ y ∈ σ}}\)
  \end{enumerate}
\end{lema}
\begin{dokaz}
  Fiksirajmo \(x\), \(y:A\).
  \begin{enumerate}
  \item Če velja \(\s x = σ\), je potem \(x ∈ \s x = σ\). Obratno, če je
    \(x ∈ σ\) potem obstaja \(x' : A\) (namreč \(x\)), da je \(x = x'\) in
    \(x' ∈ σ\), torej je po definiciji \(\s x = σ\).
  \item Po prvi točki je \(\s x = \s y\) natanko \(x ∈ \s y\), torej velja \(x = y\).
  %\item Če je \(x = y\) potem \(\s x\) očitno zadošča desni strani. Obratno, če
  %  za nek \(σ\) velja \(x ∈ σ ∧ y ∈ σ\), pa po definiciji enojca velja \(x = y\).
    \qedhere 
  \end{enumerate}
\end{dokaz}
\begin{posledica}
  Velja \(\for{σ : \g A}{\exist{x : A}{σ = \s x}}\), torej so znotraj vsi enojci
  oblike \(\s a\), za nek \(a : A\).
\end{posledica}

\begin{konstrukcija}\label{cons:res}
  Naj bo \(a ∈ A\) in \(U ∈ ℒ\). Potem obstaja natanko en enojec
  \(a{\res U} ⊑ A\), za katerega velja
  \(\e a ⊩ \for{x:A}{x ∈ a{\res U} ⇔ x=a∧U}\). V posebnem velja
  \(\e{a{\res U}} = \e a∧U\).
\end{konstrukcija}
\begin{dokaz}
  Gornja formula enolično določa podtip, namreč
  \(a{\res U} ≔ \set{x:A}{x=a∧U}\). To je podenojec, saj je manjši od \(\s a\).
  Gornja formula potem velja po definiciji.
  Velja tudi \(\e{a{\res U}} = \exist{x:A}{x=a∧U} = \e a∧U\).
\end{dokaz}

\begin{konstrukcija}
  Naj bo \(a : I → A\) družina elementov, za katero velja \(Uᵢ∩Uⱼ ⊩ aᵢ = aⱼ\),
  kjer so \(Uᵢ ≔ \e{aᵢ}\). Potem obstaja natanko en enojec \(∨a\), za katerega
  za vsak \(i ∈ I\) velja \(Uᵢ ⊩ ∨a{\res{Uᵢ}} = \s{aᵢ}\) in je
  \(\e{∨a} = ⋃ᵢUᵢ\). 
\end{konstrukcija}
\begin{dokaz}
  Naj bo \(∨a ≔ \set{x:A}{\exist{i:\c I}{x=aᵢ}}\). To je enojec, saj če sta
  \(x\) in \(y ∈ ⋁a\), za neka \(i\) in \(j\) velja \(x = aᵢ\) in \(y = aⱼ\).
  Vrednost \(x=aᵢ\) je manjša od \(\e{aᵢ}=Uᵢ\), torej smo na \(Uᵢ∩Uⱼ\). Potem pa
  po predpostavki velja \(aᵢ = aⱼ\), in sta \(x\) in \(y\) enaka.

  Po definiciji je \(aᵢ ∈ ∨a{\res{Uᵢ}}\) res, saj obstaja \(i:\c I\), da bo
  \(aᵢ=aᵢ\). Prav tako je razpon \(∨a\) enak uniji razponov elementov družine,
  saj na vsakem od njih obstaja element \(∨a\).

  Če je pa \(σ\) nek drug enojec, za katerega veljajo gornje enakosti, je pa
  nujno enak \(∨a\) na vsakem od \(Uᵢ\), torej mu je enak tudi na celotnem
  razponu.
\end{dokaz}

Enojci nam torej dajo način, kako razširiti tip z vsemi zožitvami in zlepki
njenih elementov. Vprašanje pa je, kolikokrat moramo to konstrukcijo ponoviti,
da nam to ne doda nobenih novih elementov.

\begin{definicija}\label{def:compl}
  Tip \(A\) je \emph{poln}, kadar je preslikava množic elementov \(a ↦ \s a\)
  bijekcija. Polno podkategorijo polnih tipov označimo s \(\cat{CSet}(ℒ)\).
\end{definicija}

Do sedaj smo delali z navadnimi tipi, ampak polni tipi imajo veliko poželjnih
lastonsti. A to pomeni, da moramo začeti znova s polnimi tipi? Namreč, do sedaj
smo imeli zgolj en primer polnega tipa, v primeru~\ref{ex:reals}. Izkaže se, da
temu ni tako.

% ⟨-⟩ definira idempotentno monado. To mi avtomatsko da naslednjih par
% rezultatov (specifično do izreka da so polne ℒ-množice refleksivna
% podkategorija).
\begin{lema}\label{th:compl-is-compl}
  Tip \(\g A\) je poln.
\end{lema}
\begin{dokaz}
  Pokazati moramo, da je preslikava \(σ ↦ \s σ\) bijekcija.
  Injektivnost sledi neposredno iz druge točke gornje leme.
  % to je inverz enote (in je množenje).
  Naj bo potem \(Σ ∈ \g{\g A}\). Definirajmo \(τ ≔ \set{x : A}{\s x ∈ Σ}\).
  To je enojec, saj velja
  \[
    x∈τ ∧ y∈τ ⇔ \s x ∈ Σ ∧ \s y ∈ Σ ⇒ \s x = \s y ⇔ x = y\text.
  \]

  Pokažimo še, da je \(Σ = \s τ\), torej \(τ ∈ Σ\).
  Ker je \(τ\) enojec obstaja nek \(a : A\), da je \(a ∈ τ\), torej je
  \(\s a ∈ Σ\). Poleg tega pa, ker je \(a ∈ τ\) je \(τ = \s a\), torej je
  \(τ ∈ Σ\).
  
  Sledi, da za vsak enojec v \(\g{\g A}\) obstaja natanko en enojec v \(\g A\),
  ki se vanj slika, tako da je preslikava \(\s -\) res bijekcija, in je \(\g A\)
  polna.
\end{dokaz}
\begin{opomba}
  Ta izek nam torej pove, da lahko \(\g A\) pravimo \emph{napolnitev tipa A}.
\end{opomba}

Sedaj lahko vsakemu tipu priredimo poln tip. Še več, ta tip je izpeljana iz tipa
\(A\), torej lahko vse trditve o \(\g A\) izrazimo z \(A\) (specifično, z enojci
\(A\)). Se pa izkaže, da to ni potrebno, saj lahko trditve o \(\g A\) bolj
neposredno primerjamo s trditvami o \(A\).

\begin{izrek}\label{th:sigmaiso}
  Tip \(\g A\) je izomorfna \(A\).
\end{izrek}
\begin{dokaz}
  % {-} je enota monade σ, če je η njen inverz, kaj je njena povezava z
  % množenjem? Plus lahko spustimo pol dokazov, da je {-} morfizem.
  Vemo že, da se \(A\) vloži v \(\g A\) z morfizmom \(a ↦ \s a\).
  Njen inverz je \({η(σ,a) ≔ \i{a ∈ σ}}\).
  Očitno je \(η(\s a) = a\). Oglejmo si potem \(\s{η(σ)}\). Ker je sčasoma
  \(σ = \s a\), je \(\s{η(σ)} = \s{η(\s a)} = \s a\). To pa pomeni, da je
  \(\s{η(σ)} = σ\), torej je res inverz.
\end{dokaz}
\begin{posledica}\label{th:set-eq-cset}
  Kategorija tipov je ekvivalentna kategoriji polnih tipov.
\end{posledica}

To torej pomeni, da lahko v internem jeziku vedno predpostavimo, da so
tipi polne, četudi niso. Definirajmo bolj točno, kaj to zares pomeni.

Najprej, lahko vse relacije na \(A\) razširimo do relacij na \(\g A\). Tako bomo
lahko formule v internem jeziku s prosto spremenljivko tipa \(A\) razširili do
formule s prosto spremenljivko tipa \(\g A\).
\begin{konstrukcija}
  Naj bo \(R\) relacija na \(A\). Potem je relacija
  \[ {\hat R(σ) ≔ \exist{x : A}{x ∈ σ∧R(x)}} \]
  enolična relacija na \(\g A\), za katero velja \(R(a) ⇔ \hat R(\s a)\).
\end{konstrukcija}
\begin{dokaz}
  Očitno velja \(\hat R(\s a) ⇔ R(a)\), zaj za \(x\) vzamemo kar \(a\).
  Naj bo \(Q\) neka druga relacija, in naj velja \(R(a) ⇔ Q(\s a)\).

  Naj bo \(σ : \g A\). Potem je enak nekemu \(\s a\), tako da preverimo zgolj,
  če je \(\hat R(\s a) ⇔ Q(\s a)\). Ampak ta sta po predpostavki oba \(R(a)\),
  torej sta enaka.
\end{dokaz}
Če torej terme \(A\) smatramo kot termre \(\g A\), lahko kar vse relacije
zamenjamo s konstrukcijo zgoraj, in ne eksplicitno ločujemo med \(R\) in
\(\hat R\).

\begin{izrek}
  Formula \(φ\) je veljavna natanko tedaj, ko je veljavna formula, v kateri
  vse relacije \(R\) zamenjamo z \(\hat R\), vse domene kvantifikacije \(A\)
  zamenjamo z njihovimi napolnitvami \(\g A\), in vse konstante \(a\) zamenjamo
  z \(\s a\).
\end{izrek}
Ker so relacije \(\hat R\) enolično določene, jih lahko še naprej označujemo kar
z \(R\). Prav tako, ker je \(\s -\) vložitev \(A\) v \(\g A\), lahko konstante
tipa \(A\) smatramo kar kot konstante tipa \(\g A\). Nazadnje, spremenimo vse
simbole \(∈\) v \(=\). To deluje, saj je \(\g{\g A} ≅ \g A\), torej imamo lahko
največ en ``nivo'' elementov, torej bodo vsi primerljivi z \(=\).

Oglejmo si najprej, kaj to pomeni na primeru.
\begin{trditev}
  Velja \(\for{σ : \g A}{\exist{x : A}{x ∈ σ}}\).
\end{trditev}
\begin{dokaz}
  Po gornjem izreku gornja formula velja natanko tedaj, ko velja
  \[ \for{σ:\g A}{\exist{x:\g A}{x = σ}}\text. \]
  To je pa očitno res, saj za \(x\) vzamemo kar \(σ\).
\end{dokaz}

To se torej izkaže za zelo koristno, saj pomeni, da lahko v interni logiki
uporabljamo vse lastnosti polnih tipov, ampak ko prevajamo formule v
zunanji svet pa lahko vseeno delamo le z začetnim naborom elementov.
Najpomembnejša posledica pa je, da če je \(f\) morfizem, lahko na \(f[a]\)
gledamo kot term tipa \(B\). Res, ker je \(f[a]\) enojec, in je \(B ≅ \g B\),
lahko vsako formulo s spremenljivko tipa \(B\), v katero vstavimo \(f[a]\),
preprosto interpretiramo kot formulo nad \(\g B\). Potem pa po gornjem izreku
vemo, da to ohranja veljavnost, tako da ne produciramo nobene nove trditve.
Paziti je le treba, da če v internem jeziku konstruiramo \emph{elemente} tipa
\(B\), nam \(f[a]\) očitno ne definira dejanskega elementa množice \(B\).

Od tod naprej označujmo enojec \(f[a]\) z \(f(a)\). Ta zapisa sta v edinem
kontekstu, kjer lahko pride do zmede ekvivalentna, saj velja
\(f(a,b) ⇔ f[a] = \s b\), tako da ne pride do težav.
TODO: actually, smatrejmo enojce kot terme tipa \(B\)

\begin{dokaz}[Dokaz izreka]
  Dokaz poteka po indukciji. Naredimo primer za univerzalni kvantifikator.
  Formula \(\for{x:A}{φ(x)}\) velja natanko tedaj, ko za vsak \(a ∈ A\) velja
  \(\e a ⇒ φ(a)\). Po drugi strani pa je \(\for{σ:\g A}{φ(σ)}\) veljavna natanko
  tedaj, ko za vsak enojec \(σ : A → ℒ\) velja \(\exist{x:A}{x ∈ σ} ⇒ φ(σ)\).

  Očitno sta za enojce \(\s a\) ta dva pogoja enaka, torej veljavnost formule za
  \(\g A\) implicira tisto za \(A\). Obratno pa, naj bo \(σ : A → ℒ\) poljuben
  enojec, in naj velja formula za \(A\).
  V internem jeziku je potem \(σ = \s a\) za nek \(a\), torej je
  \(φ(σ) ⇔ φ(\s a)\), ki pa po predpostavki drži.
\end{dokaz}

\begin{trditev}\label{th:ℒmor-into-compl-is-map}
  Naj bo \(f : A ↬ B \) in \(B\) poln tip. Tedaj obstaja operacija
  \(φ : A → B\), za katero velja \(\i{φ(a) = b} = f(a,b)\). 
\end{trditev}
\begin{dokaz}
  Za vsak \(a ∈ A\) je slika \(f(a)\) enojec, torej po polnosti \(B\) natanko
  določa en element \(B\), ki ga označimo \(φ(a)\). To definira preslikavo
  \(φ\).

  Po definiciji je \(\e{φ(a)} = \exist{b:B}{b ∈ f[a]} = \e a\).
  Sedaj pa, če je \(a = a'\), je \(f(a) = f(a')\), torej je \(φ(a) = φ(a')\).
\end{dokaz}
\begin{posledica}\label{th:set-eq-cset-with-maps}
  Kategorija polnih tipov je ekvivalentna kategoriji, katere
  \catdef
    {so polni tipi in}
    {so funkcije \(f : A → B\), ki zadoščajo sledečima pogojema:
      \begin{itemize}
      \item \(⊩ a = a' ⇒ f(a) = f(a')\) in
      \item \(⊩ \e{f(a)} ⇒ \e a\).
      \end{itemize}}
\end{posledica}


\subsubsection{Lastnosti morfizmov}

Za konec pa lahko izračunamo nekaj koristnih lastnosti morfizmov. Zgoraj smo že
povedali, da lahko pod določenimi pogoji vrednosti funkcij obravnavamo kot terme
tipa kodomene. Videli smo že, da lahko pišemo \(f(a) = b\) namesto \(f(a,b)\),
ampak nam to omogoča tudi druge koristne okrajšave.

\begin{lema}
  Morfizma \(f\) in \(g : A ↬ B\) sta enaka natanko tedaj, ko velja 
  \[ ⊩ \for{x : A}{f(x) = g(x)}\text. \]
\end{lema}
\begin{dokaz}
  Če sta \(f\) in \(g\) enaka potem formula očitno velja.
  
  Pokažemo sedaj drugo smer previdno, brez posebne rabe notranje polnosti \(B\).

  Predpostavimo torej, da velja gornja formula, in da velja \(f(a,b)\) za neka
  \(a\) in \(b\). Potem po predpostavki vemo, da velja \(f(a) = g(a)\). Če to
  enakost razpišemo, dobimo, da obstaja \(b' ∈ B\), tako da veljata \(f(a,b')\)
  in \(g(a,b')\). Potem je pa \(b = b'\) zaradi enoličnosti \(f\), torej velja
  tudi \(g(a,b)\). Ker je vloga \(f\) in \(g\) simetrična, ter sta \(a\) in
  \(b\) poljubna, velja \(f(a,b)\) natanko tedaj, ko velja \(g(a,b)\), torej sta
  \(f\) in \(g\) enaka.
\end{dokaz}

Gornji lemi se ponavadi pravi \emph{funkcionalna ekstenzionalnost}, saj pravi da
sta si funkciji enaki natanko tedaj, ko sta enaki na vseh vrednostih. Izkaže se
tudi, da je to primerna relacija za definicijo \emph{tipa} morfizmov iz \(A\) v
\(B\).

\begin{konstrukcija}\label{cons:exponent}
  \emph{Eksponentni tip \(A\) na \(B\)} je množica morfizmov \(A ↬ B\) z
  enakostjo \(f=g ⇔ \for{x:A}{f(x)=g(x)}\) in ga označimo \(A ↬ B\) ali \(B^A\).
\end{konstrukcija}
\begin{dokaz}
  To je tip, saj je relacija očitno simetrična in tranzitivna.
  Pokazati je torej treba le, da obstaja morfizem \(\ev : (A↬B)×A ↬ B\), za
  katerega velja, da za vsak \(e : C×A ↬ B\) obstaja enolična preslikava
  \(u : C ↬ A ↬ B\), da je \(e = \ev∘(u×\id)\). Če to enakost zapišemo na
  elementih dobimo, da mora veljati
  \[ e(c,a) = \ev∘(u×\id)(c,a) = \ev(u(c),a) = u(c)(a)\text. \]
  To nam enolično določa preslikavo \(u\) in je dokaz končan.
\end{dokaz}

Tako lahko potem rečemo, da sta morfizma enaka natanko tedaj, ko sta enaka kot
elementa tipa \(A ↬ B\), zato lahko brez problema uporabljamo isti zapis za oba.

\begin{trditev}\label{th:Ω-is-subobj-class}
  Tip \(Ω\) je \emph{klasifikator podobojektov}.
  % množica \(ℒ\) skupaj z enakostjo \(⇔\) in ga označimo \(Ω\).
\end{trditev}
\begin{dokaz}
  V trditvama~\ref{th:ℒsub-is-map-to-Ω} in~\ref{th:ℒsub-is-sub} smo že pokazali,
  da lahko vsakemu monomorfizmu \({m : S ↬ A}\) priredimo enoličen morfizem
  \(χ_S : A ↬ Ω\), da je \(S ≅ χ_S⁻¹(⊤)\), torej je \(Ω\) res klasifikator
  podobjektov.
\end{dokaz}

Kot ponavadi bomo definirali potenčni tip \(𝒫A\) kot eksponent \(A ↬ Ω\), a kot
smo povedali že prej v trditvi~\ref{th:ℒsub-is-map-to-Ω}, so to natanko podtipi.

\begin{konstrukcija}\label{cons:subobjs}
  \emph{Tip podtipov \(A\)} ozpiroma \emph{potenčni tip \(A\)} je eksponentni
  tip \(A ↬ Ω\). Ta je enak tipu na množici podtipov \(A\), z isto enakostjo kot
  na ekponentnem tipu. Označimo ga z \(𝒫{A}\).
\end{konstrukcija}
% \begin{dokaz}
%   V~\ref{th:ℒsub-is-map-to-Ω} smo pokazali, da sta množici izomorfni. Poleg
%   tega, je \(S =_{A ↬ Ω} T\) natanko tedaj, ko \(\for{x:A}{x ∈ S ⇔ x ∈ T}\),
%   torej ko je \(S(a) = T(a)\) za vse \(a ∈ A\). To pa natanko pomeni, da sta
%   \(S\) in \(T\) enaka kot preslikavi, torej enaka v konstantem tipu.
% \end{dokaz}

Sedaj ko imamo dostop do vrednosti morfizmov, pa lahko karakteriziramo
epimorfizme in monomorfizme. V običajni teoriji množic so te natanko surjekcije
in injekcije, kar se izkaže za resnično tudi za morfizme med tipi.

Najprej pa konstruirajmo še nekaj konstrukcij tipov, saj jih potrebujemo
v dokazu.
\begin{konstrukcija}
  Za tipa \(A\) in \(B\) je množica \(A+B\) z enakostjo generirano z relacijami
  \(ι₀(x) = ι₀(x') ⇔ x=x'\) in \(ι₁(y) = ι₁(y') ⇔ y=y'\), kjer sta \(x\) in
  \(x'\) prosti spremenljivki tipa \(A\), \(y\) in \(y'\) pa tipa \(B\).
  Označimo ga kar z \(A+B\). Poleg tega sta kanonični vložitvi \(ιᵢ\) operaciji.
\end{konstrukcija}
\begin{dokaz}
  Pokazati je treba, da sta vložitvi strogi in ekstenzionalni.
  Brez škode za splošnost lahko to pokažemo zgolj za \(ι : A → A+B\).
  Pri obeh primerih bomo imeli enakost v \(A+B\) zgolj na komponenti \(A\), tako
  da se bo enakost \(ι(a) = ι(a')\) vedno prevedla kar na \(a = a'\). Potem je
  pa preslikava očitno stroga in ekstenzionalna.
\end{dokaz}
\begin{konstrukcija}
  \emph{Kojedro} morfizma \(f : A ↬ B\) je zlepek tipov \(B\) in \(B\) po
  podmnožici \(f[A]\). Označimo ga \(\coker(f)\).
\end{konstrukcija}
\begin{dokaz}
  Kot v Uvodu v geometrijsko topologijo ta zlepek konstruiramo kot kvocient
  tipa \(B+B\) po relaciji generirani z \(ι₁(b) \sim ι₂(b) ⇔ b ∈ f[A]\).
\end{dokaz}

\begin{definicija}
  Morfizem \(f : A ↬ B\) je \emph{surjektiven}, ko velja
  \[ ⊩ \for{y : B}{y ∈ f[A]}\text, \]
  in \emph{injektiven}, ko velja
  \[ ⊩ \for{x,y:A}{f(x) = f(y) ⇒ x = y}\text. \]
\end{definicija}
\begin{trditev}
  Surjekcije so natanko epimorfizmi v \(\cat{Set}{\p{ℒ}}\).
\end{trditev}
\begin{dokaz}
  Naj bo \(f : A ↬ B\).

  Denimo, da je \(f\) surjektiven, \(g\) in \(h : B ↬ C\), in \(g ∘ f = h ∘ f\).
  Naj bo \(b : B\) in dokažimo \(g(b) = h(b)\).
  Po surjektivnosti potem obstaja \(a : A\), da je \(b = f(a)\). Potem je pa
  \(g(b) = g(f(a)) = h(f(a)) = h(b)\).

  Po drugi strani pa predpostavimo, da je \(f\) epimorfizem.
  Poglejmo si potem vložitvi v kojedro \(ι₁,ι₂ : B ↬ \coker(f)\).
  Te \(f\) po konstrukciji očitno izenači, saj je \(\coker(f)\) ravno zlepek
  kopij \(B\) po sliki \(f\). Torej sta po predpostavki enaki, saj je \(f\)
  epimorfizem. Tedaj pa za vsak \(b : B\) velja, da je \(ι₁(b) = ι₂(b)\), torej
  da je \(b ∈ f[A]\).
\end{dokaz}

\begin{trditev}
  Injekcije so natanko monomorfizmi v \(\cat{Set}{\p{ℒ}}\).
\end{trditev}
\begin{dokaz}
  Naj bo \(f : B ↬ C\).

  Denimo, da je \(f\) injektiven, \(g\) in \(h : A ↬ B\), in \(f ∘ g = f ∘ h\).
  Naj bo \(a : A\) in dokažimo \(g(a) = h(a)\).
  Vemo, da je \(f(g(a)) = f(h(a))\). Po injektivnosti to potem pomeni, da velja
  \(g(a) = h(a)\), kar smo tudi želeli.

  Obratno, naj bo \(f\) monomorfizem in \(a\), \(a' : A\).
  Denimo, da velja \(f(a) = f(a')\) in naj bosta \(g, h : \bb1 ↬ A\) definirana
  s predpisoma \(g(*) ≔ a\) ter \(h(*) ≔ a'\). Potem pa velja tudi
  \(f(g(*)) = f(a) = f(a') = f(h(*))\), torej je \(f∘g = f∘h\). Od tod pa
  sledi, da je \(g = h\), torej velja \(a = g(*) = h(*) = a'\).
\end{dokaz}

Sedaj se pa želimo vprašati, kaj so bijekcije tipov. V teoriji množic vemo, da
so to ravno izomorfizmi, in res to velja tudi pri nas. Za morfizem \(f : A ↬ B\)
lahko definiramo dual \(fᵒ : B×A → ℒ\) s predpisom \(fᵒ(b,a) ≔ f(a,b)\).
Kompozituma z dualom sta identiteti, zares je pa treba pokazati, da je \(fᵒ\)
morfizem.

\begin{trditev}
  Za \(f : A ↬ B\) je \(fᵒ\) morfizem natanko tedaj, ko je \(f\) bijektiven.
  V tem primeru potem velja \(f∘fᵒ = \id = fᵒ∘f\), torej je \(fᵒ\) inverz \(f\).
\end{trditev}
\begin{dokaz}
  Opazimo da je \(fᵒ\) res celovita natanko tedaj, ko je \(f\) surjektivna, in
  da je enolična natanko tedaj, ko je \(f\) injektivna.
  Pokažimo sedaj le eno neenakost, saj je druga simetrična.

  Naj bo \(a = fᵒ(f(a'))\), torej \(f(a)=f(a')\). Ker je \(f\) bijektivna, je
  \(a = a'\), in velja \(\id = fᵒ∘f\).
\end{dokaz}

TODO: vezno besedilo
\begin{trditev}\label{th:lpov-exponentiable}
  Če je \(X\) lokalno povezan, velja \(\c A ↬ B ≅ \c{A ↝ B}\).
\end{trditev}
\begin{dokaz}
  Naj bodo \(f : \c A ↬ B\), \(g : \c{A ↝ B}\), in \(a : \c A\).
  Najprej, obstja pokritje \(C\), tako da sta na njem \(g\) in \(a\) konstantna.
  Zaradi lokalne povezanosti, lahko predpostavimo, da je \(C\) zares particija.
  Potem lahko \(f(a) = g(a)\) definiramo na \(U ∈ C\) preprosto kot
  \(f(a,g(a))\), saj na vsakem elementu \(C\) velja \(g(a) ∈ B\).

  Potem definiramo preslikavo \(φ(f,g) ≔ \for{x:\c A}{f(x) = g(x)}\).

  Naj sedaj velja \(φ(f) = φ(f')\). Potem za vse \(x : \c A\) velja
  \(f(x) = f'(x)\), torej je \(φ\) injektivna. Naj bo \(g : \c{A ↝ B}\).
  Potem pa naj bo \(f(a, b) ≔ ⋁\set{U ∈ C}{U ⊩ g(a) = b}\).
  Za tega potem velja \(f(x) = g(x)\), torej velja \(φ(f,g)\).

  Sledi, da je \(φ\) izomorfizem med \(\c A ↬ \c B\) in \(\c{A ↝ B}\).
\end{dokaz}

\begin{trditev}
  Objekt \(\c{B^A}\) je znotraj enak topološkemu prostoru \(B^A\) s kompaktno
  odprto topologijo.
\end{trditev}
\begin{dokaz}
  Naj bo \(σ\) enojec tipa \(\c{B^A}\). Potem slika elemente množice \(B^A\) v
  elemente \(ℒ\). Če je \(t ∈ \e σ\), je \(\set{f : A → B}{t ⊩ f ∈ σ}\)
  podmnožica \(B^A\).
\end{dokaz}



%%% Local Variables:
%%% TeX-master: "main"
%%% End:
