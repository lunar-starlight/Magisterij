\section{Topološki modeli}\label{sec:modeli}

% Teorija modelov morda zveni kot zelo abstraktna in filozofska zadeva (govora je
% o matematičnih svetovih), vendar je pa ideja sama blizu vsakemu matematiku, ki
% je dokončal drugi letnik dodiplomskega študija.
% Situacija je namreč zelo podobna teoriji grup. Struktura grupe je skupek
% aksiomov (tako kot jih ima konstruktivna logika ali pa teorija množic), medtem
% ko so pa grupe same natanko \emph{modeli} teh aksiomov, in na model logike
% mislimo na isti način.

% Seveda pa grupe niso edina struktura, za katero lahko izvedemo to analogijo.
% Lahko tudi gledamo modele monoidne, kolobarske, vektorske,~itd.~strukture, prav
% tako pa lahko gledamo modele topološke strukture ali pa modele izračunljivostne
% strukture (recimo turingove stroje).

% V logiki in teoriji množic, se pogosto sprašujemo, ali so kakšne trditve
% \emph{neodvisne} od aksiomov našega sistema. Na primer aksiom izbire je
% neodvisen od preostalih aksiomov teorije množic, hipoteza kontinuuma je
% neodvisna od teorije množic z izbiro,~itd. Neodvisnost je mogoče malce
% nedostopen pojem, še posebej za matematike, ki verjamejo v absolutno resnico.
% Namreč, kako lahko trditev ni niti resnična niti neresnična? Ampak bistvo je v
% tem, da trditev ima resničnostno vrednost \emph{v vseh modelih}, vendar če je ta
% resničnostna vrednost različna v različnih modelih, je trditvi ne moremo
% dodeliti, tako da bo bilo to res v vseh modelih! Ključno je namreč, da noben
% model logike ni \emph{odlikovan}, torej nimamo \quot{standardnega modela}.

% To se vse sliši nekoliko komplicirano, a nam je zares že intimno znano. V
% teoriji grup namreč vemo za \quot{komutativnost}, za katero vemo, da se je ne da
% dokazati iz aksiomov grupe, prav tako pa ne velja njena negacija. To pa vemo
% natanko zato, ker obstajajo in komutativne in nekomutativne grupe (oziroma
% modeli aksiomov grup). V teoriji grup prav tako nimamo \quot{standardne grupe},
% za katero velja natanko vse kar velja za vse grupe.

% V logiki takim stvarem pravimo \quot{neodvisne trditve}, v teoriji
% izračunljivosti tem pravimo \quot{neizračunljive funkcije}, v algebri in
% topologiji pa \quot{lastnosti algebraične strukture oz.~topološkega prostora}.

% Skratka, prehod med aksiomatskim sistemom in modeli nam je kot matematikom znan,
% v algebri smo bili z njim vzgojeni že od malega, a v logiki te sreče žal nismo
% imeli. Tako se moramo na stara leta pruičiti teh metod, ki so pa logikom brez
% dvoma enako pomembne kot so grupe algebrajikom, ali pa prostori topologom.

% Kot smo pa omenili v uvodu, pa obstajajo modeli logike, ki so zgrajeni iz
% topoloških prostorov. Tem pravimo topološki modeli, in vse logične trditve v tem
% modelu se prevedejo v topološke trditve o topološkem prostoru. Sledi naravno
% vprašanje, ali lahko vzpostavimo nekak slovar med neodvisnimi trditvami
% (t.~j.~klasičnimi principi v konstruktivni logiki) in topološkimi lastnostmi, ki
% so nam znane.

% Do tega se vrnemo kasneje, v naslednjem razdelku, za zdaj nas pa čaka malo
% teorije snopov, da lahko topološke modele sploh definiramo.

% TODO: rewrite

% Oglejmo si najprej primer zveznih funkcij iz \(X\) v \(ℝ\).
% Zanje se vedno lahko vprašamo, če so pozitivne, negativne, ali so gladke,
% ipd.~vendar nas pogosto zanima tudi \emph{kje} za določeno funkcijo neka
% lastnost velja. Recimo preprosto, da je \(f : ℝ → ℝ\) identiteta. Tedaj je
% pozitivna na \((0,∞)\), negativna na \((-∞,0)\), gladka pa na celem \(ℝ\).
% Klasično je pozitivnost funkcije resničnostna vrednost. Z drugimi besedami,
% pozitivnost je predikat na (zveznih) realnih funkcijah. Mi pa zares želimo
% opredeliti, kje ta lastnost velja, ne zgolj če velja na celem prostoru.
% Želimo torej, da ima ``prava'' pozitivnost vrednosti v podmnožicah prostora
% \(X\), in da bo imela topologija \(X\) kaj vpliva naj bodo to zgolj odprte
% podmnožice.

% Želimo pa tudi obravnavati funkcije, ki niso definirane na celotni domeni, na
% primer \(x ↦ x⁻¹\). Tako naš primer razširimo na množico vseh funkcij \(U → ℝ\),
% kjer je \(U ∈ 𝒪X\), in označimo množico vseh teh funkcij z \(R\). Potem pa za
% \(f ∈ R\) definiramo \emph{definicijsko območje} oziroma \emph{razpon} kot
% domeno funkcije \(f\), in ga označimo \(‖f‖\).
% Na to množico lahko sedaj uvedemo predikat enakosti, ki seveda meri, na kateri
% množici se dve funkciji ujemata, na očiten način:
% \[ ⟦f = g⟧ = \int\set{t ∈ ‖f‖∩‖g‖}{f(t) = g(t)}\text. \]

% Ni naključje, da preslikavam \(R → 𝒪X\) pravimo predikati, saj se da pokazati,
% da za vsako polno Heytingovo algebro (kar \(𝒪X\) je) obstaja nek model
% konstruktivne matematike, tako da so resničnostne vrednosti natanko odprte
% množice \(X\). V tem smislu \(⟦f = g⟧\) predstavlja kar enakost med funkcijami,
% \(‖f‖\) je pa predikat obstoja elementa \(‖f‖ = \exist{f : R}{⊤}\). Velja tudi
% enakost \(‖f‖ = ⟦f = f⟧\), torej zares predikata \(‖-‖\) ne potrebujemo.

% V splošnem, množicam kot so \(R\), torej takim, da imajo definirano enakost z
% vrednostmi v \(𝒪X\) pravimo \emph{Heytingovo vrednotene množice},
% \emph{\(𝒪X\) vrednotene množice}, ali na kratko \emph{\(𝒪X\)-množice}.

V tem razdelku najprej podrobno opišemo, kako interpretiramo logiko odprtih
množic v topološkem prostoru samem. Kasneje potem to logiko razširimo do logike
višjega reda, ki tvori \emph{topološki model}. V tem delu ne razvijemo vseh
detajlov formalno, le predstavimo teorijo topoloških modelov na tak način, da bo
najbolj koristna za rabo v kasnejših poglavjih. Za natančne detajle o
intuicionistični logiki delnih elementov si lahko ogledate~\cite{Scott79}. Za
detajle o konstrukciji modelov te logike si lahko ogledate~\cite{FS79}, za
detajle o njihovih bolj računskih lastnostih pa~\cite[pogl.~2.6-2.8]{Borceux94}.

Topološke modele bomo zasnovali na topoloških prostorih in naša definicija
topološkega modela bo omenjala zgolj odprte množice, tako da se brez škode
omejimo na \(T₀\) prostore.
\begin{definicija}
  Prostor \(X\) je \(T₀\), ko za vse različne točke \(x\), \(y ∈ X\) velja, da
  obstaja odprta množica \(U ∈ 𝒪X\), ki vsebuje natanko eno od njih.
\end{definicija}
Ekvivalentna formulacija \(T₀\) lastnosti je, da če sta dve točki vsebovani
v istih odprtih množicah, sta potem enaki. V splošnem prostoru torej med takimi
točkami ne moremo razlikovati zgolj z odprtimi množicami, kar v kontekstu
topoloških modelov ni zaželeno.


\subsection{Logika odprtih množic}\label{sec:modeli-logika-odprtih}

Naj bo \(X\) topološki prostor. Podrobno si oglejmo, kako logične operacije
delujejo v logiki odprtih množic.

Kot smo povedali želimo, da se resnica spreminja vzdolž prostora \(X\). To
pomeni, da bodo resničnostne vrednosti ``merile'' \emph{kje} neka izjava velja.
Želimo tudi, da so resničnostne vrednosti \emph{odprte} množice, saj sicer
topologija ne bo imela vpliva na logiko. Torej vsak \(U ∈ 𝒪X\) predstavlja ``res
je na \(U\)''. To pomeni, da je \emph{resnica} \(⊤\) kar \(X\), in \(∅\)
\emph{neresnica} \(⊥\).

Naredimo najprej nekaj primerov, kako to deluje. V topološkem modelu bodo vlogo
realnih števil igrale zvezne funkcije \(U → ℝ\), za \(U ∈ 𝒪X\). Poglejmo si
sedaj pozitivnost realnega števila, v tej logiki. Naj bo \(f : X → ℝ\) zvezna
funkcija, torej realno število v topološkem modelu. Če je v interni logiki sedaj
obravnavamo izjavo "\(f > 0\)", ta ne pravi ``\(f\) je povsod pozitivna'', zares
predstavlja \emph{množico}, na kateri je \(f\) pozitivna. To pomeni, da se
interpretira v (odprto) množico \(\set{t ∈ X}{f(t) > 0}\). To pa tudi pomeni, da
je izjava "\(f > 0\)" v topološkem modelu \emph{res}, ko je ta množica enaka
\(X\), torej, ko je \(f\) pozitivna. Negacija relacije \(>\) je \(≤\), tako je
torej negacija te izjave "\(f ≤ 0\)". Ker množica \(\set{t∈X}{f(t)≤0}\) ni
odprta, moramo vzeti njeno notranjost. To nam že namigne, da bo v splošnem
negacija definirana kot notranjost komplementa oziroma
\emph{zunanjost}.

Obrnimo se sedaj na veznike. Naj bosta \(f\), \(g : X → ℝ\), \(U ≔ f⁻¹(0, ∞)\),
in \(V ≔ g⁻¹(0, ∞)\). Torej je \(U\) natanko vrednost izjave "\(f > 0\)", \(V\)
pa vrednost izjave "\(g > 0\)". Potem "\(f > 0 ∧ g > 0\)" predstavlja izjavo
"funkciji \(f\) in \(g\) sta obe pozitivni", kar je res natanko na preseku
množic \(U\) in \(V\). Podobno je disjunkcija \(U ∨ V\) natanko unija \(U\) in \(V\).
% Za negacijo moramo malo razmisliti. Izraz \(f > 0\) lahko preprosto negiramo, in
% dobimo pogoj \(f ≤ 0\), ampak množica \(t ∈ X\) za katere to drži tudi ni odprta
% (in je natanko komplement \(U\), kar bi bil drugi kandidat za negacijo \(U\)).
% Ampak lahko pa vzamemo njeno notranjost, torej ``največjo odprto množico, na
% kateri \(f > 0\) ne velja''. Temu se potem reče tudi ``zunanjost množice
% \(U\)'', označeno \(\ext{U}\), iz angleško ``\foreignlanguage{english}{exterior}''.

Topologija zares tvori Heytingovo mrežo. To pomeni, da ima poleg konjunkcije in
disjunkcije tudi implikacijo. Te ponavadi v topologiji ne vidimo, a je vseeno
pomembna.
\begin{definicija}
  Za odprti množici \(U\) in \(V\), je \(U ⇒ V\) odprta množica, za katero za
  vse \(W ∈ 𝒪X\) velja \(W ⊆ U⇒V\) natanko tedaj, ko velja \(W∩U ⊆ V\).
\end{definicija}
Če želimo implikacijo torej definirati s formulo, velja
\begin{gather} U⇒V = ⋃\set{W∈𝒪X}{W∩U⊆V}\text. \label{eq:impl} \end{gather}
Poljubna unija odprtih množic je odprta, in množica \(U⇒V\) je element množice v
desni strani formule~\ref{eq:impl}, saj velja \(U⇒V ⊆ U⇒V\), torej je desna
stran kar enaka \(U⇒V\). Izkaže pa se, da obstaja še boljša karakterizacija,
namreč \(W∩U⊆V\) velja natanko tedaj, ko velja \(W ⊆ V∪Uᶜ\). Potem je \(U⇒V\)
natanko unija vseh odprtih podmnožic \(V∪Uᶜ\), torej je kar njena notranjost. To
je zelo podobno klasični definiciji implikacije, kjer \(P ⇒ Q\) definiramo kot
\(Q ∨ ¬P\). V naši logiki to ne drži, saj se \(V ∨ ¬U\) interpretira v
\(V ∪ \int{\p{Uᶜ}}\). Naj bo \(X\) recimo prostor Sierpinskijeva, torej prostor
\(\{0,1\}\), kjer je le točka \(1\) odprta. Potem je \(\{1\} ⇒ \{1\}\) očitno
res, ampak \(\{1\}∨¬\{1\}\) je pa le \(\{1\}\), torej nista enaka.

Uvedimo oznako za interpretacijo logičnih formul v logiki odprtih množic. Naj
torej \(\i φ\) predstavlja odprto množico, na kateri \(φ\) velja.
V tabeli~\ref{tab:int-odp} je podana interpretacija izjavnega računa v logiki
odprtih množic.
\begin{table}[h]
  \centering
  \begin{align*}
    &\i ⊤ ≔ X\\
    &\i ⊥ ≔ ∅\\
    &\i{φ ∧ ψ} ≔ \i φ ∩ \i ψ\\
    &\i{φ ∨ ψ} ≔ \i φ ∪ \i ψ\\
    &\i{¬φ} ≔ \ext{\i φ}\\
    &\i{φ ⇒ ψ} ≔ \int{\p{\i ψ ∪ \i φᶜ}}\\
    &\i{φ ⇔ ψ} ≔ \i{(φ⇒ψ)∧(ψ⇒φ)}
  \end{align*}

  \caption{Interpretacija formul v logiki odprtih množic}
  \label{tab:int-odp}
\end{table}

\begin{opomba}
  Ker je \(W∩U ⊆ V\) natanko tedaj ko je \(W ⊆ U⇒V\), je \(U ⊆ V\) natanko
  tedaj, ko velja \(⊤ = U⇒V\), torej ko je \(U⇒V\) ``res''. To pa pomeni, da
  lahko na \(U ⊆ V\) gledamo kot ``iz \(U\) sledi \(V\)''.
\end{opomba}

S tem smo vsakemu prostoru priredili izjavni račun, sedaj pa ga želimo
obogatiti do logike prvega (in nato višjega) reda. Naj bo \(P : A → 𝒪X\).
Preslikave z vrednostmi v \(𝒪X\) igrajo vlogo predikatov v logiki odprtih
množic, saj vsakemu elementu \(a ∈ A\) priredijo neko resničnostno vrednost.
Sedaj lahko začnemo izpeljevati interpretacijo kvantifikatorjev. Interpretacija
univerzalnega kvantifikatorja je največja odprta množica, ki je vsebovana v
\(P(a)\) za vsak \(a ∈ A\), torej je notranjost preseka teh množic.

Obstoj je malo bolj kompliciran. Vrnimo se nazaj na primer, kjer so resničnostne
vrednosti pozitivnost realnih funkcij. Potem bi ``obstaja \(f\), da je
\(f > 0\) in velja \(P(f)\)'' lahko interpretirali kot da iščemo pozitivno funkcijo
\(f\), za katero velja \(P\). Ampak bolj skladno z razpravo zgoraj bi bilo, da
iščemo največjo odprto množico, na kateri kak tak \(f\) zadošča \(P(f)\).
Ta množica je pa kar unija vseh odprtih množic, na katerih to velja, in to
gotovo velja na vsakem \(P(f)\). Vrednost tega obstoja je torej natanko unija
\(P(f)\). To se potem tudi sklada z intuicijo, da je eksistenčni kvantifikator
nekakšna neskončna disjunkcija, saj smo tudi to interpretirali kot unijo.
V splošnem sta pravili interpretacije univerzalnih kvantifikatorjev torej sledeči:
\begin{align*}
  \for{a : \c A}{P(a)}   &≔ \int{\parens[\bigg]{⋂_{a ∈ A}P(a)}}\\
  \exist{a : \c A}{P(a)} &≔ ⋃_{a ∈ A}P(a)
\end{align*}
Tukaj pišemo \(a : \c A\), da bo to skladno s kasnejšo notacijo, ampak za zdaj
se to bere kot "\(a\) element \(A\)".

Nekaj primerov formul, ki uporabljajo kvantifikatorje bi bili na primer
\(\for{U:\c{𝒪X}}{U∨¬U}\) ali \(\for{U:\c{𝒪X}}{\exist{V:\c{𝒪X}}{U ⇔ ¬V}}\). V
prvi prepoznamo princip izključene tretje možnosti, druga pa nima posebnega
imena, a pravi, da je vsaka resničnostna vrednost negacija. Izkaže se, da čeprav
ti formuli konstruktivno \emph{nista} ekvivalentni, karakterizirata isti razred
topoloških prostorov. Dokaz tega dejstva se nahaja v~\cite[izr.~2.1]{GJ08}, a ga
v tem delu ne ponovimo.

Oglejmo si najprej, kaj zares pomeni, da je kvantificiran izraz ``res''.
Če je notranjost množice \(S ⊆ X\) enaka \(X\), mora biti tudi množica \(S\)
enaka \(X\), saj je kvečjemu večja od svoje notranjosti. Podobno, če je presek
podmnožic \(X\) enak \(X\), morajo biti te enake \(X\).
Torej je izjava "\(\for{a:\c A}{P(a)}\)" res natanko tedaj, ko je za vsak
\(a ∈ A\) množica \(P(a)\) enaka \(X\).

Po drugi strani, je "\(\exist{a:\c A}{P(a)}\)" res natanko tedaj, ko množice
\(P(a)\) tvorijo pokritje \(X\). 

\begin{lema}
  Za \(U ∈ 𝒪X\) velja \(U∨¬U\), natanko tedaj, ko je \(U\) zaprta.
\end{lema}
\begin{dokaz}
  Interpretacija \(U∨¬U\) je \(U ∪ \ext U\). Če je \(U\) zaprta, je
  \(\ext U = Uᶜ\) in je \(U∨¬U = ⊤\). Obratno, ker je \(U ⊥ \ext U\), iz
  \(U∨¬U = ⊤\) sledi \(\ext U=Uᶜ\), in je \(U\) zaprta.
\end{dokaz}

\begin{trditev}\label{th:lem-is-discrete}
  Nad topološkim prostorom velja princip izključene tretje možnosti natanko
  tedaj, ko je prostor diskreten.
\end{trditev}
\begin{dokaz}
  Princip izključene tretje možnosti pravi, da velja formula
  \(\for{U : \c{𝒪X}}{U ∨ ¬U}\). Po gornjem to natanko pomeni, da za vsako odprto
  množico velja \(U∨¬U\), torej po lemi, da je zaprta. To je očitno res za
  diskretne prostore, saj je \emph{vsaka} podmnožica zaprta. Pokažimo torej
  drugo smer.

  Naj bo \(t ∈ X\) in \(s ∈ \cl\{t\}⧵\{t\}\). Potem po \(T₀\) lastnosti obstaja
  odprta množica \(U\), ki ju ločuje. Ker je \(s\) v zaprtju \(t\) mora biti
  \(U\) nujno okolica \(t\). Ta je po predpostavki zaprta, torej vsebuje
  \(\cl\{t\}\). To je protislovno, saj \(U\) ne sme vsebovati točke \(s\).
  Sledi, da taka točka \(s\) ne obstaja, torej je \(\cl\{t\} = \{t\}\). To
  pomeni, da so točke zaprte, torej so po predpostavki tudi odprte in je prostor
  diskreten.
\end{dokaz}

Naredimo še eno karakterizacijo, tokrat DeMorganovega zakona.
\begin{definicija}
  \emph{DeMorganov zakon} je formula \(\for{U,V:\c{𝒪X}}{¬(U∧V) ⇒ ¬U∨¬V}\).
\end{definicija}

\begin{definicija}
  Prostor je \emph{ekstremalno nepovezan}, ko je zaprtje vsake odprte množice
  odprto.
\end{definicija}
\begin{trditev}\label{th:wlem-is-ext-disc}
  Nad topološkim prostorom velja DeMorganov zakon natanko tedaj, ko je prostor
  ekstremalno nepovezan.
\end{trditev}
\begin{dokaz}
  DeMorganov zakon je ekvivalenten trditvi \(\for{U:\c{𝒪X}}{¬U ∨ ¬¬U}\), kar po
  gornji lemi pravi, da so vse zunanjosti množic zaprte. To pomeni, da so
  njihovi komplementi, torej zaprtja množic, odprta, kar je natanko kar smo
  želeli.
\end{dokaz}


\subsection{Heytingovo vrednotene množice}\label{sec:modeli-heyting}

Oglejmo si spet primer naravnih števil nad nekim prostorom \(X\). To bodo zvezne
preslikave iz odprtih podmnožic \(X\) v \(ℕ\). Najprej lahko vsaki taki
preslikavi dodelimo ``resničnostno vrednost obstoja'', oziroma \emph{razpon}, ki
bo kar njena domena. To označimo z \(‖-‖\). Če je \(n : U → ℕ\), potem \(n\)
obstaja zgolj na \(U\), saj izven \(U\) nima vrednosti. Različni taki naravni
števili lahko tudi primerjamo, tako da preprosto pogledamo množico, na kateri
sta enaki: \(⟦n = m⟧ = \set{t ∈ \e n ∩ \e m}{n(t) = m(t)}\), kjer seveda pazimo,
da \(t\) jemljemo zgolj iz razpona obeh števil. Načeloma bi morali vzeti
notranjost te množice, saj morajo biti resničnostne vrednosti odprte, ampak v
tem primeru, ker so funkcije lokalno konstantne, bo ta množica odprta. Potem
se pa izkaže, da velja enakost \(⟦n = n⟧ = \e n\), tako da če znamo primerjati
vsa števila, lahko izpeljemo tudi razpon, kar bomo tudi vzeli kot osnovni
gradnik naših objektov.

\begin{definicija}\label{def:ℒset}
  \emph{Heytingovo vrednotena množica} oziroma \emph{tip} je množica \(A\),
  skupaj s preslikavo \(⟦- =_A -⟧ : A×A → 𝒪X\), tako da za vse \(a\), \(b\), in
  \(c ∈ A\) velja
  \begin{gather*}
    ⟦ a =_A b ⟧ ⊆ ⟦ b =_A a ⟧\text{ in}\\
    ⟦ a =_A b ⟧ ∩ ⟦ b =_A c ⟧ ⊆ ⟦ a =_A c ⟧\text.
  \end{gather*}
  Če je iz konteksta razvidno, kateri množici pripada preslikava \(⟦- =_A -⟧\),
  indeks opustimo. Če želimo ločiti tip \(A\) od množice \(A\), na kateri je
  definiran, množici \(A\) pravimo \emph{množica elementov (tipa A)}.

  Kot zgoraj naj bo \(‖a‖ ≔ ⟦a = a⟧\) \emph{razpon \(a\)}.
\end{definicija}

Če to beremo v logiki odprtih množic, gornja aksioma izražata simetričnosti
in tranzitivnosti enakosti, izražene z resničnostnimi vrednostmi \(𝒪X\), tako da
bi lahko rekli, da so tipi natanko množice opremljene z (interno) delno
ekvivalenčno relacijo. Refleksivnosti ne zahtevamo, saj nam razpon
predstavlja \emph{obstoj} elementa. Razpon \(\e a\) je največja odprta množica,
kjer \(a\) obstaja. Refleksivnost bi naivno torej pravila, da je vsak obstoj
poln, oziroma da je \(\e a = X\) za vse \(a ∈ A\). To ni zaželeno, saj želimo
govoriti tudi o delnih elementih, torej elementih, ki niso definirani povsod.
Tako se refleksivnost bolj pravilno glasi, da za vsak \(a ∈ A\) velja
\(\e a ⊆ \i{a = a}\), kar drži po definiciji. In res, kot bomo videli
kasneje v interni logiki, je enakost refleksivna.

\begin{primer}\label{ex:nats}
  Na \(\set{f : U → ℕ}{U ∈ 𝒪X\text{, }f\text{ lokalno konstantna}}\) definiramo
  enakost
  \[ ⟦n = m⟧ = \set{t ∈ X}{n(t) = m(t)}\text. \]
  To je tip, ki ga označimo z \(𝒩\).
\end{primer}

\begin{primer}\label{ex:reals}
  Na \(\set{f : U → ℝ}{U ∈ 𝒪X\text{, }f\text{ zvezna}}\) definiramo enakost
  \[ ⟦f = g⟧ = \int{\p{\set{t ∈ X}{f(t) = g(t)}}}\text. \]
  To je tip, ki ga označimo z \(ℛ\).
\end{primer}

Gornja dva primera sta instanci bolj splošne konstrukcije, saj so zvezne
preslikave v \(ℕ\) lokalno konstantne (in lokalno konstantne so očitno zvezne).
Tej konstrukciji v splošnem pravimo \emph{snop lokalnih prerezov}. Specifično so
njeni elementi lokalni prerezi projekcije \(π : X×A → X\), ampak konstrukcijo
lahko izvedemo le za množice \(A\) opremljene s topologijo, in je naravni način
kako topološki prostor \(A\) ``internalizirati''. Je pa vredno omeniti, da lahko
vsakemu tipu priredimo tak topološki prostor, da bo snop lokalnih
prerezov izomorfen začetnemu tipu. Podrobnosti si lahko ogledate
v~\cite[pogl.~2]{MM92}, kjer izvedejo konstrukcijo prostora,
in~\cite[pogl.~4]{FS79} ali~\cite[pogl.~2.6-2.8]{Borceux94}, kjer pokažejo
ekvivalenco med Heytingovo vrednotenimi množicami in snopi, kot so definirani v
prvem viru.

Struktura Heytingovo vrednotenih množic zajema več kot le snope lokalnih
prerezov.

\begin{konstrukcija}
  Množica \(∅\) je tip. Množica \(\{*\}\) z enakostjo \(\i{*=*} = X\) je tip, ki
  ga označimo z \(\bb 1\). Pravimo jima \emph{prazen tip} in \emph{tip z enim
    elementom}.
\end{konstrukcija}
\begin{dokaz}
  Očitno je enakost na \(\{*\}\) simetrična in tranzitivna. Prav tako ima
  množica \(∅\) za enakost prazno preslikavo, ki na prazno zadošča pogojema.
\end{dokaz}

\begin{primer}
  Množica \(ℕ\) skupaj z enakostjo definirano kot
  \[ ⟦n = m⟧ ≔
    \begin{cases}
      X &; n = m\\
      ∅ &; n ≠ m
    \end{cases}
  \]
  je tip, ki ga označimo z \(\c ℕ\).
\end{primer}

Ti primeri so instance bolj splošne konstrukcije imenovane \emph{konstantni tipi}.
\begin{konstrukcija}\label{def:constant-hvs}
  Naj bo \(A\) množica in enakost na njej definirana s predpisom
  \(\i{a = b} ≔ ⋃\set{X}{a = b}\). To je tip, ki ga označimo \(\c A\).
\end{konstrukcija}
\begin{dokaz}
  Množica \(\i{a = b}\) je \(X\) natanko tedaj, ko je \(\i{b = a} = X\), tako da
  je enakost simetrična.

  Če je \(\i{a = b} ∩ \i{b = c} = X\), vemo, da je \(a = b = c\), torej je
  \(\i{a = c} = X\). Če je pa ta presek prazen, je gotovo manjši od česarkoli
  na desni strani \(⊆\).
\end{dokaz}
Konstantni tip \(\c A\) zapišemo kar \(A\), kadar to ne povzroči dvoumnosti.

Konstantni tipi nam služijo kot vložitve navadnih množic v notranji svet
topološkega modela. Najbolj prav to pride, ko imamo družino elementov tipa, in
jo želimo smatrati kot družino tudi znotraj modela.

Poznamo tudi tipe, ki niso niti konstantni, niti snopi lokalnih prerezov.
\begin{primer}\label{ex:omega}
  Množica \(𝒪X\) skupaj z enakostjo \(\i{U = V} ≔ U ⇔ V\) je tip. Označimo ga z
  \(Ω\), saj v topoloških modelih predstavlja \emph{tip resničnostnih vrednosti}.
\end{primer}

% Ampak naša motivacija za definicijo Heytingovo vrednotenih množic so bile ravno
% množice zveznih preslikav, kar te niso.
% To je zato, ker imajo zvezne funkcije še dve pomembni lastnosti, ki jih v
% strukturi sami ne zajamemo.
% Prvič, funkcije lahko zožamo. To preprosto pomeni, da če vrednost obstaja na
% neki odprti množici, potem obstaja tudi na vsaki manjši odprti množici.
% Drugič, če imamo družino zveznih funkcij, ki se paroma ujemajo na presekih
% njihovih domen, jih lahko enolično zlepimo v zvezno funkcijo, definirano na
% uniji njihovih domen. V primeru zveznih funkcij v naravna števila je ta lastnost
% zelo zanimiva, saj je vsaka lokalno konstantna funkcija tak zlepek konstantnih
% funkcij. Potem pa če to združimo še z zožitvami, lahko rečemo, da je vsaka
% funkcija \(U → ℕ\) zlepek zožitev konstantnih funkcij \(X → ℕ\).
% Tako lahko na nek način rečemo, da so zvezne funkcije v naravna števila
% ``generirane'' z množico naravnih števil samo.
% To pa zares pomeni, da je \(𝒩\) nekakšna \emph{napolnitev} tipa \(\c ℕ\).

% Torej ne bomo zahtevali, da so naši objekti zaprti za zožitve in lepljenje, saj
% jih lahko vedno napolnimo. Izkaže pa se, da nam to ustvari nekaj težav pri
% definiciji funkcij.
Želimo tudi primeren pojem preslikave med tipi. Pričakujemo, da bodo to funkcije
\(A → B\), ki zadoščajo dvema pogojema. Prvič, upali bi, da spoštujejo enakosti
tipov, torej da velja \(\i{a=a'} ⊆ \i{f(a) = f(a')}\). Poleg tega bi
pričakovali, da funkcije ohranjajo ``nivo obstoja'', torej da velja
\(\e a ⊆ \e{f(a)}\). Izkaže pa se, da to ne bo zajelo vseh možnih preslikav, ki
bi jih želeli definirati.

\begin{primer}\label{ex:one-to-one}
  Naj bo \(\p{2, 𝒫2}\) diskreten prostor na dveh točkah.
  Tip \(A\) naj ima dva različna elementa, \(a₀\) in \(a₁\), tako da je
  \(\e{aᵢ} = \{i\}\) in \(\i{a₀ = a₁} = ∅\).
  Pri definiciji funkcije \(\bb1 → A\), ki zadošča želenim pogojem, pa naletimo
  na problem. Namreč, tip \(A\) sploh nima elementa, ki bi obstajal na celem
  prostoru, torej enačba \(X = \e * ⊆ \e{f(*)} = \{i\}\) ne velja, ne glede na
  izbiro \(i\). A vendar lahko definiramo relacijo \(R(*,aᵢ)≔\{i\}\), ki se
  izkaže da je funkcijska na primeren način. Ta se obnaša, kot da nad točko
  \(0\) slika \(*\) v \(a₀\) in nad točko \(1\) v \(a₁\).
\end{primer}

To nam da idejo, da lahko preslikave definiramo kot funkcijske relacije, seveda
spet vrednotene v logiki odprtih množic.

Definirajmo najprej, kaj pomeni, da je neka preslikava z vrednostmi v \(𝒪X\)
relacija. Prav tako definirajmo kaj pomeni, da je preslikava med tipi operacija.
Te porodijo poseben primer morfizmov, ki pa dejansko so funkcije med množicami
elementov.
\begin{definicija}
  Naj bodo \(A₁,\dots,Aₙ,B\) tipi.

  \emph{Relacija} \(R\) na \(A₁×\dots×Aₙ\) je preslikava \(A₁×\dots×Aₙ → 𝒪X\), ki
  za vse \(aᵢ ∈ Aᵢ\) zadošča pogojema
  \begin{gather*}
    \i{a₁ = a₁'} ∩ \dots ∩ \i{aₙ = aₙ'} ∩ R(a₁,…,aₙ) ⊆ R(a₁',…,aₙ')\text{ in}\\
    R(a₁,…,aₙ) ⊆ \e{a₁}∩\dots∩\e{aₙ}\text.
  \end{gather*}
  Relacijam na \(A×B\) pravimo tudi \emph{relacije med \(A\) in \(B\)}. Dve
  relaciji sta enaki, ko sta enaki kot preslikavi.

  \emph{Operacija} \(f : A₁×\dots×Aₙ ↝ B\) je preslikava \(A₁×\dots×Aₙ → B\),
  ki za vse \(aᵢ ∈ Aᵢ\) zadošča pogojema
  \begin{gather*}
    \i{a₁ = a₁'} ∩ \dots ∩ \i{aₙ = aₙ'} ⊆ \i{f(a₁,…,aₙ) = f(a₁',…,aₙ')}\text{ in}\\
    f(a₁,…,aₙ) ⊆ \e{a₁}∩\dots∩\e{aₙ}\text.
  \end{gather*}
  Dve operaciji \(f,g : A₁×\dots×Aₙ ↝ B\) sta enaki, ko za vse \(aᵢ ∈ Aᵢ\)
  velja \[ \i{f(a₁,…,aₙ) = g(a₁,…,aₙ)} = \e{a₁}∩\dots∩\e{aₙ}\text. \]
\end{definicija}

\begin{definicija}\label{def:ℒmap}
  \emph{Morfizem} \(f : A ↬ B\) med tipoma \(A\) in \(B\) je relacija med \(A\)
  in \(B\), za katero za vse \(a ∈ A\) in \(b\), \(b' ∈ B\) velja
  \begin{gather}
    f(a,b) ∩ f(a,b') ⊆ \i{b =_B b'} \tag{enoličnost}\label{eq:enoličnost-raw}\\
    \e a ⊆ ⋃_{b ∈ B} f(a,b)         \tag{celovitost}\label{eq:celovitost-raw}
  \end{gather}
\end{definicija}
Če sedaj primerjamo gornje z interpretacijo v logiko odprtih množic, je
enoličnost natanko interpretacija enoličnosti, celovitost je pa malo
spremenjena. V logiki odprtih množic bi jo izrazili kot
\[ \for{a : \c A}{\e a ⇒ \exist{b : \c B}{f(a,b)}}\text. \]
Tu smo morali dodati \(\e a\), saj je pojem vrednosti \(f\) pri \(a\) smiseln
le, če \(a\) obstaja. Definirajmo sedaj interni jezik bolj natančno, ki bo tudi
razrešil to razliko med celovitostjo zgoraj in celovitostjo, kot jo poznamo iz
teorije množic.

Želeli bi si, da bi bile operacije kaj povezane z morfizmi, in res so poseben
razred morfizmov.
\begin{trditev} 
  Vsaka operacija \(f : A ↝ B\) nam porodi morfizem tipa \(A ↬ B\) s predpisom
  \[ {\p{a,b} ↦ \e a ∩ \i{f(a) = b}}\text. \]
\end{trditev}
\begin{dokaz}
  Označimo morfizem s \(\hat f\). Enoličnost očitno sledi iz tranzitivnosti
  enakosti na \(B\). Je tudi celovit, saj velja
  \[ \e a ⊆ \e a ∩ \i{f(a) = f(a)} ⊆ \hat f(a, f(a)) ⊆ ⋃_{b∈B}\hat f(a,b)\text.\qedhere \]
\end{dokaz}


\subsubsection{Interni jezik}

Kot lahko sklepate, bomo logiki odprtih množic dodali Heytingovo vrednotene
množice kot \emph{tipe}. Definirajmo najprej, kaj pomeni, da je v internem
jeziku nek izraz \emph{term} tipa \(A\).
\begin{enumerate}
\item Element \(a ∈ A\) je term tipa \(A\).
%\item Spremenljivka tipa \(A\) je term tipa \(A\).
\item Če je \(f : A ↝ B\) operacija in \(τ\) term tipa \(A\), je \(f(τ)\) term tipa \(B\).
\end{enumerate}
Tu moramo paziti, saj lahko terme konstruiramo samo z operacijami, in ne z morfizmi.
% \emph{skonstruiramo} na enega od sledečih načinov. Najosnovnejši način je, da
% vzamemo kar dobesedne elemente tipa \(A\). Če imamo operacijo tipa \(B → A\), jo
% lahko uporabimo na nekem obstoječem termu tipa \(B\), da dobimo term tipa \(A\).
% Poleg tega pa se v izrazih lahko pojavljajo spremenljivke, recimo v
% kvantificiranih izrazih. Te interpretiramo kot spremenljivke istega tipa v
% zunanjem svetu.

Z zapisom \(τ : A\) označimo, da je term \(τ\) tipa \(A\). Za \(τ : A\)
rekurzivno definiramo \(\i τ_A\) kot element tipa \(A\):
\begin{enumerate}
\item \(\i a_A ≔ a\), za \(a ∈ A\)
%\item \(\i x_A ≔ x\), za spremenljivko \(x\) tipa \(A\)
\item \(\i{f(α)}_B ≔ f{\p{\i α_A}}\), za operacijo \(f : A ↝ B\) in \(α : B\)
\end{enumerate}

Prav tako razširimo tabelo~\ref{tab:int-odp} s tipi in relacijami v tabeli~\ref{tab:int-form}.
\begin{table}[h]
  \centering
  \begin{align*}
    &\i ⊤                    ≔ X\\
    &\i ⊥                    ≔ ∅\\
    &\i{φ ∧ ψ}               ≔ \i φ ∩ \i ψ\\
    &\i{φ ∨ ψ}               ≔ \i φ ∪ \i ψ\\
    &\i{φ ⇒ ψ}               ≔ \int{\p{\i φ ∪ \i φᶜ}}\\
    &\i{\for{x : A}{φ(x)}}   ≔ \int{⋂_{a ∈ A}\i{\e a ⇒ φ(a)}}\\
    &\i{\exist{x : A}{φ(x)}} ≔ ⋃_{a ∈ A}\i{\e a ∧ φ(a)}\\
    &\i{τ = σ}               ≔ \i{\i τ_A = \i σ_A}\\
    &\i{R(τ)}                ≔ R{\p{\i τ_A}}\text{, za relacijo \(R\) na \(A\) in \(τ : A\)}
  \end{align*}

  \caption{Interpretacija formul v internem jeziku}
  \label{tab:int-form}
\end{table}
\begin{opomba}
  Morfizmi so relacije torej jih v interni jezik dodamo kot relacijske
  simbole. Prav tako je \(\e -\) relacija, saj velja
  \(\i{a = a'}∧\e{a'} ≤ \e a\) in \(\e a ≤ \e a\), tako da tudi to dodamo kot
  relacijski simbol.

  Prav tako so enakosti Heytingovo vrednotenih množic relacije. Njihova
  interpretacija kot enakost in kot relacija enaka.
\end{opomba}

\begin{definicija}\label{def:valid}
  Formula \(φ\) brez prostih spremenljivk je \emph{veljavna na \(U\)}, ko je
  \({\i φ ≥ U}\). Formula \(φ\) je \emph{veljavna} ko je veljavna na \(X\).

  Veljavnost na \(U\) pišemo kot \(U ⊩ φ\), veljavnost pa \(⊩ φ\).
\end{definicija}

\begin{trditev}\label{th:valid-res}
  Veljavnost lahko zožimo, torej če velja \(U ⊩ φ\) in je \(V ⊆ U\), velja tudi
  \(V ⊩ φ\).
\end{trditev}
\begin{dokaz}
  Po definiciji je \(V ⊆ U ⊆ \i φ\).
\end{dokaz}

\begin{trditev}\label{th:valid-glue}
  Veljavnost lahko lepimo, torej če je \(C\) pokritje \(U\), in za vsak
  \(V ∈ C\) velja \(V ⊩ φ\), velja tudi \(U ⊩ φ\).
\end{trditev}
\begin{dokaz}
  Če za vsak \(V ∈ C\) velja \(V ⊆ \i φ\), je \(\i φ\) večji tudi od \(⋃C\), kar
  je natanko \(U\).
\end{dokaz}
To nam da zanimivo posledico, da je veljavnost ekvivalentna lokalni veljavnosti.
\begin{definicija}
  Zunanji predikat \(P : 𝒪X → \{⊤,⊥\}\) je na \(U\) \emph{lokalno ali sčasoma res},
  pišemo \(\eventually{V ⊆ U}{P(V)}\), ko obstaja pokritje \(C\) množice \(U\),
  tako da za vsak element pokritja velja \(P(V)\).
\end{definicija}
Tukaj bo \(P(V)\) najpogosteje oblike \(\exist{a∈A}{V ⊩ \e a ∧ φ(a)}\).
V tem primeru v naravnem jeziku rečemo ``sčasoma na V obstaja...''.

V topologiji lahko zapis uporabimo za izražanje lokalnih lastnosti. Na primer,
dejstvo, da je prostor \(X\) lokalno povezan lahko zapišemo s formulo
\[ \eventually{U⊆X}{U\text{ je povezana}}\text. \]
Tudi lokalno naravo veljavnosti, kot jo izražata trditvi~\ref{th:valid-res}
in~\ref{th:valid-glue} lahko elegantno izrazimo z novim zapisom:
\begin{posledica}\label{th:valid-local}
  \(U ⊩ φ\) natanko tedaj ko \(\eventually{V ⊆ U}{V ⊩ φ}\).
\end{posledica}

\begin{trditev}
  Veljavnost formule se lahko računa po tabeli~\ref{tab:kj-sem}.
  \begin{table}[h]
    \centering
    \begin{tabularx}{0.9\textwidth}{p{0.25\textwidth}X}
      \(U ⊩ ⊤\)                   & vedno\\
      \(U ⊩ ⊥\)                   & ko je \(U = ∅\)\\
      \(U ⊩ φ ∧ ψ\)               & ko \(U ⊩ φ\) in \(U ⊩ ψ\)\\
      \(U ⊩ φ ∨ ψ\)               & ko
                                    \(\eventually{V ⊆ U}{V ⊩ φ\text{ ali }V ⊩ ψ}\)\\ 
      \(U ⊩ φ ⇒ ψ\)               & ko za vsak \(V ∈ 𝒪U\) velja, da iz \(V ⊩ φ\)
                                    sledi \(V ⊩ ψ\)\newline
                                    ekvivalentno: ko velja \(U∩\i φ ⊩ ψ\)\\
      \(U ⊩ ¬φ\)                  & ko za vsak \(V ∈ 𝒪U\) velja, da iz \(V ⊩ φ\)
                                    sledi \(V = ∅\)\newline
                                    ekvivalentno: ko velja \(U ⊥ \i φ\)\\
      \(U ⊩ \for{x : A}{φ(x)}\)   & ko za vsak \(a ∈ A\) velja \(U ∩ \e a ⊩ φ(a)\)\\
      \(U ⊩ \exist{x : A}{φ(x)}\) & ko \(\eventually{V ⊆ U}{\exist{a ∈ A}{V ⊆ \e a
                                    \text{ in } V ⊩ φ(a) }}\)
    \end{tabularx}

    \caption{Veljavnost formul oziroma Kripke-Joyalova semantika}
    \label{tab:kj-sem}
  \end{table}
\end{trditev}
\begin{dokaz}
  Večina točk zgoraj je očitna, tako da se osredotočimo zgolj na disjunkcijo in
  obstoj.
  
  Po definiciji velja \(U ⊩ φ ∨ ψ\) natanko tedaj, ko je \(U ⊆ \i φ ∪ \i ψ\),
  torej, ko \(\i φ\) in \(\i ψ\) pokrivata \(U\). Želeno pokritje sestoji kar iz
  množic \(\i φ\) in \(\i ψ\), saj velja \(\i φ ⊩ φ\) in \(\i ψ ⊩ ψ\).
  Obratno naj bo \(C\) pokritje \(U\), za katerega za vsak element \(V ∈ C\)
  velja bodisi \(V ⊩ φ\), bodisi \(V ⊩ ψ\). Potem je pa \(V\) vsebovan v
  \(\i φ ∪ \i ψ\), torej je \(U ⊆ \i φ ∪ \i ψ\).

  Situacija z obstojem je popolnoma analogna. Če je
  \(U ⊆ ⋃_{a ∈ A}\e a ∩ \i{φ(a)}\), potem množice \(\e a ∩ \i{φ(a)}\) pokrivajo
  \(U\). Prav tako za \(\e a ∩ \i{φ(a)}\) obstaja \(a\), in zanj velja
  \(\e a ∩ \i{φ(a)} ⊆ \e a\) in \(\i{φ(a)} ⊩ φ(a)\). Obratno naj bo \(C\)
  pokritje \(U\), za katerega za vsak element \(V ∈ C\) obstaja \(a_V ∈ A\), da
  je \(V ⊆ \e a_V\) in \(V ⊆ \i{φ(a_V)}\). Potem pa velja
  \[ U ⊆ ⋃_{V ∈ C}V ⊆ ⋃_{v ∈ C}\e{a_V} ∩ \i{φ(a_V)} ⊆ ⋃_{a ∈ A}\e a ∩ \i{φ(a)}\text.\qedhere \]
\end{dokaz}
\begin{opomba}
  Tabela~\ref{tab:kj-sem} poda dva načina, kako preveriti veljavnost implikacije.
  Izkaže se, da je v različnih primerih lažje uporabiti različne načine.
  Če sta formuli \(φ\) in \(ψ\) preprosti, je ponavadi lažje preverjati
  \(U ∩ \i{φ} ⊩ ψ\), veljavnosti zahtevnejših implikacij pa raje prevedemo v
  implikacijo med veljavnostmi dveh formul. Tako lahko uporabimo vso matematično
  intuicijo sklepanja, kot smo navajeni. Je pa treba paziti, da \(U ⊩ φ ⇒ ψ\)
  \emph{ni} enako kot "\(U ⊩ φ\) implicira \(U ⊩ ψ\)".
\end{opomba}

Ker želimo v internem jeziku pisati matematiko, bi bilo dobro, da lahko v njem
dejansko sklepamo.
\begin{izrek}[Zdravost]\label{th:soundness}
  Intuicionistično dokazljive formule so veljavne.
\end{izrek}
Dokaz in točno definicijo dokazljivosti si lahko ogledate v~\cite{Scott79,FS79}.

Na tem mestu povejmo, kako točno deluje "sklepanje v internem jeziku".
Večinoma poteka enako kot v običajni neformalni matematiki, na primer vedno
moramo vedeti, katere spremenljivke smo uvedli in kakšnih tipov so, slediti pa
moramo tudi trenutnim hipotezam. Poleg tega se lahko sklicujemo na vmesne
rezultate. Formalno se hipoteze shranjuje na levi strani operatorja \(⊩\) in
spremenljivke v kontekstu v zunanjem jeziku. Ilustrirajmo to na primeru. Če
dokazujemo \(U ⊩ x = y ⇒ φ(x) = φ(y)\), je to po tabeli~\ref{tab:kj-sem}
ekvivalentno \(U ∩ \i{x = y} ⊩ φ(x) = φ(y)\). Tu smo hipotezo \(x = y\) dali na
levo stran, spremenljivki \(x\) in \(y\) sta bili pa verjetno vpeljani nekje
prej v zunanjem jeziku. Ko sklepamo v internem jeziku to izrazimo na sledeč
način:
\begin{quotation}
  Za \(x\), \(y : A\) naj velja \(U\) in predpostavimo \(x = y\). Potem...
\end{quotation}
Paziti pa je treba pri dokazovanju in uporabi kvantifikatorjev, ker imamo
opravka z delnimi elementi. Dokaz \(\for{x:A}{φ(x)}\) v interni logiki poteka
tako, da uvedemo spremenljivko \(x:A\) in dodatno predpostavimo \(\e x\):
\begin{quotation}
  Naj bo \(a : A\) in predpostavimo \(\e x\).
\end{quotation}
Da se izognemo ponavljanju, drugi del izpustimo, tako da pišemo zgolj
``naj bo \(a : A\)''. Pri uporabi eksistenčnega kvantifikatorja se zgodi
podobno. Če imamo v kontekstu \(\exist{x:A}{φ(x)}\), želimo v navadni matematiki
reči "naj bo \(a ∈ A\) tak, da zadošča \(φ(a)\)". To deluje tudi v topoloških
modelih, a moramo malo paziti. Kar velja je, da množice \(\e a ∩ \i{φ(a)}\)
\emph{pokrivajo} prostor \(X\). Ker je veljavnost lokalna
(trditev~\ref{th:valid-local}), zadošča pokazati trditev na vsakem od
\(\e a ∩ \i{φ(a)}\) posebej. Sedaj pa na \(\e a ∩ \i{φ(a)}\) dejansko obstaja
\(a ∈ A\), in zanj velja \(φ(a)\) v internem jeziku. Tako lahko v internem
jeziku rečemo "naj bo \(a : A\) tak, da zadošča \(φ(a)\)", ampak nam to poleg
predpostavke \(φ(a)\) doda še \(\e a\).

Pri uporabi univerzalnega kvantifikatorja ni veliko za reči, le da moramo
paziti, da term na katerem ga uporabljamo obstaja. To bo veljalo, čim smo ta
term skonstruirali v interni logiki. Pri dokazovanju eksistenčnega
kvantifikatorja podobno pazimo, da termi, ki jih skonstruiramo, dejansko
pokrijejo trenutni kontekst.

Ponovimo sedaj definicije tipov in morfizmov v internem jeziku.
\begin{redefinicija}{def:ℒset}
  \emph{Tip} je množica \(A\) z relacijo \(=_A\) na \(\c A×\c A\), za katero velja
  \begin{align*}
    &⊩ \for{x,y:\c A}{x =_A y ⇒ y =_A x}\text{ in}\\
    &⊩ \for{x,y,z:\c A}{x =_A y ∧ y =_A z ⇒ x =_A z}\text.
  \end{align*}
\end{redefinicija}
Tu kvantifikacijo interpretiramo kot na začetku v logiki odprtih množic, saj če
\(A\) ni tip zanj ne moremo uporabiti interne logike.
Zdaj pa lahko povemo, da je v interni logiki \(=_A\) ekvivalenčna relacija.
\begin{posledica}
  Za tip \(A\) velja
  \begin{align*}
    &⊩ \for{x:A}{x = x}\text{,}\\
    &⊩ \for{x,y:A}{x = y ⇒ y = x}\text{, in}\\
    &⊩ \for{x,y,z:A}{x = y ∧ y = z ⇒ x = z}\text.
  \end{align*}
\end{posledica}
Tako lahko neformalno na tipe gledamo kot ``množice z ekvivalenčno relacijo''.

\begin{redefinicija}{def:ℒmap}
  \emph{Morfizem} \(f : A ↬ B\) je relacija \(f\) med \(A\) in \(B\), za katero
  veljata
  \begin{align}
    &⊩ \for{x:A}{\for{y,y':B}{f(x,y)∧f(x,y') ⇒ y=y'}} \tag{enoličnost}\label{eq:enoličnost}\\
    &⊩ \for{x : A}{\exist{y : B}{f(x,y)}}             \tag{celovitost}\label{eq:celovitost}
  \end{align}
\end{redefinicija}
\begin{opomba}
  Pogoja enoličnosti in celovitosti lahko sedaj združimo v en pogoj
  \[ ⊩ \for{x:A}{\unique{y:B}{f(x,y)}}\text. \]
  Res, drugi pogoj izraža, da tak \(y\) obstaja, medtem ko prvi pogoj izraža,
  da je tak \(y\) enoličen.
\end{opomba}


\subsubsection{Relacije in podobjekti}

V tem podrazdelku s črkami \(A, B, C,...\) označimo tipe.

Z notranjim jezikom si lahko pomagamo pri konstruiranju relacij. Natančno to
pomeni, da bomo formule s prostimi spremenljivkami interpretirali kot
preslikave, ki bodo avtomatsko zadoščale pravilom relacij.

Najprej si olajšajmo delo, in definirajmo produkte tipov. Potem bomo lahko vse
definirali za eno spremenljivko, saj lahko relacijo na več spremenljivkah
predstavimo kot eniško relacijo (oziroma predikat) na produktu.

\begin{konstrukcija}\label{cons:prod}
  \emph{Produkt} tipov \(A\) in \(B\) je množica
  \[ \set{(a, b) ∈ A×B}{\e a = \e b} \]
  z enakostjo definiramo po točkah
  \[ \i{\p{a, b} = \p{a', b'}} ≔ \i{a = a'} ∩ \i{b = b'}\text. \]
  Označimo ga \(A×B\).

  Projekciji \(π₀ : A×B → A\) in \(π₁ : A×B → B\) sta operaciji.
\end{konstrukcija}
\begin{dokaz}
  Gornja enakost je očitno simetrična in tranzitivna, tako da tvori
  tip.

  Pokažimo le, da je projekcija \(π : A×B → A\) operacija.
  Velja \(\e{\p{a, b}} = \e a ∩ \e b = \e a\), torej velja
  \(\e{\p{a,b}} ⊆ \e{π{\p{a,b}}}\). Za drugo lastnost imamo
  \[ \i{\p{a,b} = \p{a',b'}} = \i{a=a'}∩\i{b=b'} ⊆ \i{a = a'} =
    \i{π(a,b) = π(a',b')}\text.\qedhere \]
\end{dokaz}
\begin{opomba}
  Pričakovali bi, da bi za nosilec produkta vzeli kar produkt množic elementov
  \(A\) in \(B\). Izkaže se, da če želimo, da sta projekciji operaciji, moramo
  vzeti množico zgoraj. Res, če sta projekciji operaciji velja
  \(\e{(a,b)} = \e{π(a,b)} = \e a\) (simetrično \(\e b\)). Potem sledi
  \(\e a = \e b\), kar je pa natanko pogoj na parih, ki ga imamo zgoraj.
\end{opomba}

\begin{konstrukcija}\label{cons:rel-from-formula}
  Naj bo \(φ\) formula s prosto spremenljivko \(x\) tipa \(A\). Potem je
  preslikava \(a ↦ \e a ∩ \i{φ(a)}\) relacija na \(A\).
\end{konstrukcija}
\begin{dokaz}
  Označimo to preslikavo s \(\hat φ\).
  Očitno je stroga. Prav tako je ekstenzionalna, saj velja
  \begin{align*}
    \i{a = a'} ∩ \hat φ(a')
    &⊆ \i{a = a'} ∩ \e{a'} ∩ \i{φ(a')}\\
    &⊆ \e a ∩ \i{a = a' ∧ φ(a')}\\
    &⊆ \e a ∩ \i{φ(a)} = \hat φ(a)\text.\qedhere
  \end{align*}
\end{dokaz}
\begin{opomba}
  Če je formula \(φ\) že taka, da velja \(\i{φ(a)} ⊆ \e a\) za vse \(a ∈ A\),
  lahko preprosto pišemo \(\hat φ(a) ≔ \i{φ(a)}\).
\end{opomba}

\begin{primer}
  Če je \(R\) relacija na \(A\), je \(\hat R = R\). Res, ker je \(R\) že sama po
  sebi stroga, lahko uporabimo gornjo opombo in pišemo \(\hat R(a) = \i{R(a)}\).
  To je pa natanko \(R(a)\).
\end{primer}
\begin{primer}
  Naj bo \(x ≡ y \mod 2\) formula s prostima spremenljivkama tipa \(\c ℕ\). Potem
  ta definira relacijo, ki je simetrična in tranzitivna, torej definira tip.
  Njegova množica elementov je neskončna, a je izomorfen tipu \(\c 2\).
\end{primer}
Na ta način lahko torej definiramo izpeljane tipe, je pa to najbolj uporabno pri
definiciji morfizmov.

\begin{konstrukcija}
  \emph{Kompozitum} \({g∘f : A ↬ C}\) morfizmov \(A \oset{f}{↬} B \oset{g}{↬} C\),
   je relacija
  \[ \exist{y : B}{f(x,y) ∧ g(y,z)}\text. \]
\end{konstrukcija}
\begin{dokaz}
  Konstruktivno velja, da je kompozitum funkcijskih relacij funkcijska relacija.
  Tako lahko uporabimo izrek~\ref{th:soundness} in je dokaz končan.
\end{dokaz}

\begin{konstrukcija}
  Identiteta na \(A\) je kar \(⟦- =_A -⟧\).
\end{konstrukcija}
\begin{dokaz}
  Enakost na \(A\) je v internem jeziku identitetna relacija, torej je po
  izreku~\ref{th:soundness} enota za kompozitum.
\end{dokaz}

\begin{definicija}
  Kategorijo tipov z morfizmi in gornjim kompozitumom in identiteto označimo z
  \(\cat{Set}(𝒪X)\).
\end{definicija}

Oglejmo si, kaj so podobjekti tipa \(A\). Ti so do izomorfizma natančno
monomorfizmi s kodomeno \(A\). Poleg tega so urejeni, tako da je \(S ≤ T\)
natanko tedaj, ko obstaja monomorfizem \(S → T\). Vemo tudi, da ponavadi
lahko podobjekte predstavimo s \emph{predikati} na množici, torej funkcijami iz
\(A\) v množico resničnostnih vrednostih.

V našem primeru igra topologija \(𝒪X\) vlogo množice resničnostnih vrednosti,
tako so predikati kar morfizmi tipa \(A ↬ Ω\). Izkaže pa se, da imajo ti še
lepšo karakterizacijo.

\begin{lema}\label{th:ℒsub-is-map-to-Ω}
  Za vsak morfizem \(f : A ↬ Ω\) obstaja enolična operacija \(\hat f : A ↝ Ω\),
  tako da je morfizem porojen z \(\hat f\) enak \(f\).
\end{lema}
\begin{dokaz}
  Definirajmo \(\hat f(a) ≔ f(a,⊤)\).
  Očitno je \(\hat f(a) ≤ \e a\), saj je velja \(f(a,⊤) ≤ \e a\).
  Denimo sedaj, da je \(a=a'\). Potem je \(f(a,⊤) = f(a',⊤)\), torej je
  \(\hat f(a) = \hat f(a')\), torej je \(\hat f\) res operacija.

  Naj bosta \(a ∈ A\) in \(U ∈ 𝒪X\). Brez škode za splošnost predpostavimo, da
  je \(\e a = X\).
  \begin{gather*}
    f(a,U) ∩ U = f(a,U) ∩ \i{U = ⊤} ⊆ f(a, ⊤) = \hat f(a)\\
    f(a,U) ∩ f(a, ⊤) ⊆ \i{U = ⊤} = U
  \end{gather*}
  To dvoje skupaj nam pove, da je \(f(a,U)\) manjši od \(\i{\hat f(a) = U}\).

  Obratno, začnimo z \(\i{\hat f(a) = U}\) in pokažimo, da je manjši od
  \(f(a,U)\). Ker je \(f\) celovita, množice \(f(a, V)\) pokrivajo prostor, tako
  da zadošča pokazati, da velja \(\i{\hat f(a) = U}∩f(a,V) ⊆ f(a,U)\).
  Po delu zgoraj velja \(f(a,V) ⊆ \i{\hat f(a) = V}\), torej je
  \(\i{\hat f(a) = U}∩f(a,V) ⊆ U=V\). Potem pa lahko po enoličnosti \(f\)
  zapišemo \(\i{\hat f(a) = U}∩f(a,V) ⊆ f(a,U)\).

  Če je \(g : A ↝ Ω\) neka druga operacija, ki porodi morfizem enak \(f\), je
  \(\e a = \i{g(a) = g(a)} = \i{f(a,g(a))} = \i{\hat f(a) = g(a)}\), torej sta
  operaciji \(\hat f\) in \(g\) enaki.
\end{dokaz}

Dokaz \(\i{\hat f(a) = U} ⊆ f(a,U)\) že napol zgleda kot matematično sklepanje,
ampak ima veliko ponavljanja. Tega v navadni matematiki nebi videli, ampak če
želimo pokazati neko vsebovanost drugače pač ne gre. Ampak smo že prej govorili,
da želimo na vsebovanost gledati kot implikacijo, torej je veriga vsebovanosti
zgolj veriga implikacij, oziroma sklepov. Te ponavadi pišemo v prozi, v naravnem
jeziku, tako da bi želeli to emulirati tudi tu. Izkaže se, da to lahko storimo s
pomočjo internega jezika.
\begin{dokaz}
  Naj bosta \(a:A\), \(U:Ω\), in naj velja \(\hat f(a) = U\).
  Ker je \(f\) celovita, obstaja \(V:Ω\), da velja \(f(a,V)\). Potem po prvem
  delu dokaza velja tudi \(\hat f(a) = V\). Po tranzitivnosti enakosti torej
  velja \(U = V\) in dobimo \(f(a,U)\).
\end{dokaz}
Če podrobno pogledate prvo verzijo dokaza, so koraki popolnoma identični, le da
smo v drugem pisali dokaz, kot bi ga pisali v običajni matematiki. Tam si lahko
zapomnemo kaj ``že velja'', in to uporabimo na primerni točki. Tako bomo tudi v
prihodnje raje pisali dokaze v internem jeziku, saj so ti dokazi bližje
matematični praksi kot verige vsebovanosti.

Recimo torej eniškim relacijam podtipi in pokažimo, da so natanko podobjekti.
\begin{definicija}\label{def:subset}
  \emph{Podtip} \(S ⊑ A\) je eniška relacija na \(A\).
  Namesto \(S(τ)\) v internem jeziku pišemo \(τ ∈ S\). Kvantifikatorje razširimo
  z na podtipe tako, da \(\e a\) v definiciji zamenjamo z \(S(a)\).
\end{definicija}

\begin{konstrukcija}\label{cons:𝒪X-sub-lattice}
  Podtipi tvorijo delno ureditev
  \[ S ⊑ T :⇔\ X ⊩ \for{x : A}{x ∈ S ⇒ x ∈ T}\text. \]
\end{konstrukcija}

Definirajmo sedaj boljši zapis za konstrukcijo~\ref{cons:rel-from-formula}.
\begin{definicija}\label{notation:setbuilder}
  Naj bo \(φ\) formula s prosto spremenljivko \(x : A\). Potem relacija \(\hat φ\)
  definirana v~\ref{cons:rel-from-formula} določa podtip \(A\), ki ga označimo z
  \(\set{x : A}{φ}\).
\end{definicija}

\begin{definicija}\label{notation:image}
  Vsakemu morfizmu \(f : A ↬ B\) in podtipoma \(S ⊑ A\) in \(T ⊑ B\) lahko
  priredimo
  \begin{enumerate}
  \item podtip \(f[S] ⊑ B\), definiran kot
    \(\set{y : B}{\exist{x ∈ S}{f(x,y)}}\), imenovan \emph{slika} in
  \item podtip \(f⁻¹[T] ⊑ A\), definiran kot
    \(\set{x : A}{\exist{y ∈ T}{f(x,y)}}\), imenovan \emph{praslika}. 
  \end{enumerate}
\end{definicija}

\begin{konstrukcija}\label{cons:sing}\label{notation:sing-image}
  Za \(a ∈ A\) lahko tvorimo \(\s a ≔ \set{x : A}{x = a}\). Temu podtipu
  pravimo \emph{enojec}.

  Za enojce lahko poenostavimo zapis za sliko in prasliko,
  \[ f[a] ≔ f[\s a] = \set{y : B}{f(a,y)} \text{ in}\]
  \[ f⁻¹[b] ≔ f⁻¹[\s b] = \set{x : A}{f(x,b)} \text,\]
  kot smo vajeni.
\end{konstrukcija}

Primer te konstrukcije smo zares že videli, v dokazu
leme~\ref{th:ℒsub-is-map-to-Ω}. Tam smo zares iz morfizma \(f : A ↬ Ω\)
skonstruirali podtip \(f⁻¹(⊤) ⊑ Ω\). Iz teorije kategorij pa vemo, da če je
\(f\) karakteristična preslikava podobjekta \(S\), je potem \(S = f⁻¹(⊤)\),
torej je to natanko ista konstrukcija. Pokažimo sedaj, da so podtipi natanko
podobjekti.

Preden se lotimo dejanskega dokaza pokažimo, da lahko iz vsakega podtipa
zgradimo dejanski tip, ki se vloži v svoj nadtip. To je zares konstrukcija
podobjekta iz podtipa.
\begin{konstrukcija}\label{cons:ℒset-from-ℒsub}
  Naj bo \(P ⊑ A\). Tvorimo tip \(\hat P\) na množici \(A\) z enakostjo
  definirano kot \(x =_A x'∧P(x)\).
  Identiteta na \(A\) je monomorfizem \(m : \hat P ↬ A\).
\end{konstrukcija}
\begin{dokaz}
  Relacija je simetrična, saj je \(\i{x=_Ax'}∩P(x)\) enak \(\i{x=_Ax'}∩P(x')\),
  tranzitivnost pa očitno sledi iz tranzitivnosti \(=_A\).

  Za morfizem \(m\) velja, da za vsak \(f : B ↬ \hat P\), \(a ∈ A\), in
  \(b ∈ B\) velja \(m∘f(b,a) = f(b,a)\). Od tod sledi, da je \(m\) monomorfizem.
\end{dokaz}

\begin{trditev}\label{th:ℒsub-is-sub}
  Delni ureditvi podtipov \(A\) in podobjektov \(A\) sta si ekvivalentni.
\end{trditev}
\begin{dokaz}
  Naj bo \(m : S ↬ A\) monomorfizem. Temu lahko priredimo sliko \(m[S]\). Ta
  prireditev je monotona, tako da je injektivna in dobro definirana na
  množici ekvivalenčnih razredov.
  Obratno, vsakemu podtipu \(P ⊑ A\) priredimo monomorfizem \(m : \hat P ↬ A\),
  kot v konstrukciji~\ref{cons:ℒset-from-ℒsub}.
  
  Preverimo, da sta si ti operaciji inverzni.
  Če začnemo z \(m : S ↬ A\), se \(m\) zoži na \(S ↬ A/m[S]\). Prav tako je ta
  morfizem surjektiven, saj za vsak \(a : A/m[S]\) vemo, da ima razpon
  \(\e a ∧ a ∈ m[S]\), torej obstaja nek \(s : S\), da je \(m(s,a)\).
  Obratno, če je \(P ⊑ A\) je \(a ∈ \id[\hat P]\) natanko tedaj, ko velja \(a ∈ P\).
\end{dokaz}

Za konec pa definirajmo še kvocientne tipe. Najprej pokažimo 

\begin{definicija}
  Relacija \(R\) na \(A×A\) je refleksivna, ko velja \(⊩ \for{x:A}{R(x,x)}\).
\end{definicija}

\begin{lema}
  Za refleksivno relacijo \(R\) na \(A×A\) velja
  \[ ⊩ \for{x,y:A}{x = y ⇒ R(x,y)}\text. \]
\end{lema}
\begin{dokaz}
  Naj bosta \(a\) in \(b\) tipa \(A\) enaka. Potem je \(R(a,b) = R(a,a)\), po
  prvi lastnosti relacij. Po predpostavki \(R(a,a)\) velja za vse \(a : A\),
  torej velja tudi \(R(a,b)\).
\end{dokaz}

\begin{konstrukcija}\label{cons:quot}
  Naj bo \(R\) ekvivalenčna relacija na \(A×A\). Potem množica \(A\) z enakostjo
  \(R\), tvori tip, ki mu pravimo \emph{kvocient} \(A\) po \(R\) in ga označimo
  \(\quot A R\).

  Identiteta na \(A\) je kvocientni morfizem \(q : A ↬ \quot A R\).
\end{konstrukcija}
\begin{dokaz}
  Enakost bo očitno simetrična in tranzitivna, tako da rabimo preveriti samo, da
  identiteta res definira ustrezen morfizem.

  % Najprej pokažimo, da velja \(⊩\for{x,y:A}{x = y ⇒ R(x,y)}\). Ker je preslikava
  % refleksivna, to pomeni, da velja \(⊩ \for{x:A}{R(x, x)}\). Poleg tega
  % pa, ker je relacija, imamo \(⊢ \p{a, a'} = \p{a', a'} ∧ R(a',a') ⇒ R(a,a')\).
  % Leva stran implikacije se poenostavi na \(a = a'\), ker smo na \(\e{a'}\) in
  % je \(R(a',a')\) res.

  Naj bo \(f : A ↬ B\) morfizem, za katerega velja \(R(a,a')∧f(a',b) ≤ f(a,b)\).
  Tedaj bo \(f\) tudi morfizem tipa \(\quot A R ↬ B\), torej je \(q\) res
  kvocientna reslikava.
\end{dokaz}


\subsubsection{Polni tipi}

Pogosto omenjamo, da zaradi lokalne narave naše logike in splošnosti definicije
tipov nekateri elementi ne obstajajo. Oglejmo si spet
primer~\ref{ex:one-to-one}. Naj bo \(X = 2\), in \(A = \{a₀,a₁\}\), kjer je
\(\e{aᵢ} = \{i\}\).
Relacijo \(R\) med \(\bb1\) in \(A\) definiramo s predpisom \(R(*,aᵢ) ≔ \{i\}\).
Ta je funkcijska relacija. Ker je enolična, ima torej \(f[*]\) kvečjemu en
element. Ampak ne obstaja noben element \(a ∈ A\), ki bi zadoščal \(f[*] = \s a\),
torej \(f[*]\) ni zares enojec. Takim elementom pravimo \emph{podenojci}.

% Se pa izkaže, da velja \(\{i\} ⊩ aᵢ ∈ f[*]\), torej ima \(f[*]\) nad vsako točko
% element. V interni logiki torej velja \(\exist{x:A}{x∈f[*]}\). Torej iz
% notranjega sveta topološkega modela ne moremo razlikovati med enojci in
% podenojci (seveda, razen za prazen podenojec), tako da bomo tem vseeno pravili
% \emph{enojci}. Izkaže se, da imajo enojci zelo bogato strukturo, namreč z njimi
% bomo lahko tvorili zožitve in zlepke elementov tipov, kot smo želeli v začetni
% motivaciji.

% Seveda pa kot prej, ni nobenega elementa v \(A\), ki bi bil povsod element \(f[*]\).
% Ker pa nam \(f[*]\) vseeno natanko predstavlja ta element, lahko gornjo
% lastnost, torej, \(𝒪X\)-podmnožica z največ enim elementom, vzamemo kot nekakšno
% ``napolnitev'' \(𝒪X\)-množice \(A\). Izkaže se, da nam bo to dovolilo
% neposredno izraziti zožitve in zlepke elementov.

\begin{definicija}\label{def:sing}
  \emph{Podenojec} tipa \(A\) je podtip \(σ ⊑ A\), za katerega velja
  \[ ⊩ \for{x,y:A}{x ∈ σ ∧ y ∈ σ ⇒ x = y}\text. \]
\end{definicija}
\begin{opomba}
  Za podenojce se ponavadi uporablja grške črke \(σ, ρ, τ,…\). V literaturi se
  jim pravi \emph{enojci}~\cite[def.~4.10]{FS79}. Ker smo termin ``enojec'' že
  defnirali v konstrukciji~\ref{cons:sing}, jim bomo zaenkrat pravili podenojci,
  a je standardna terminologija upravičena, kot bomo videli kasneje.
\end{opomba}

% Sedaj smo drugič defninirali besedo enojec, enkrat v
% konstrukciji~\ref{cons:sing} kot konstrukcijo specifičnega podtipa, in še enkrat
% zgoraj kot lastnost podtipov. Izkaže se, da to ni dvoumno, saj imajo enojci iz
% konstrukcije~\ref{cons:sing} lastnost iz definicije~\ref{def:sing}, prav tako pa
% kot omenjeno zgoraj, iz notranjega pogleda je vsak podtip z lastnostjo
% definicije~\ref{def:sing} tudi sam enojec (čim definiramo ustrezne tipe, da
% lahko to zatrdimo). Zato torej tem podtipom pravimo enojci, kljub temu, da bi
% se zares morali imenovati \emph{podenojci}. Ta terminologija je tudi standardna
% v literaturi~\cite{FS79,Borceux94}. Pokažimo sedaj 

\begin{trditev}\label{th:sing-is-subsing}
  Za vsak \(a ∈ A\) je enojec \(\s a\) tudi podenojec.
\end{trditev}
\begin{dokaz}
  Če imamo \(x\), \(y ∈ \s a\), je po defniciji potem \(x = a = y\), torej je
  \(x=y\).
\end{dokaz}

\begin{konstrukcija}\label{cons:compl}
  \emph{Tip enojcev \(A\)} je množica podenojcev \(A\) z relacijo
  \[ σ = τ ≔ \exist{x : A}{x ∈ σ ∧ x ∈ τ}\text. \]
  Označimo ga z \(\g A\).
\end{konstrukcija}
\begin{dokaz}
  Gornje očitno definira relacijo, saj je definirana v internem jeziku.
  Poleg tega je očitno simetrična, tako da si poglejmo le tranzitivnost.
  Naj bo \(σ = τ\) in \(τ = ρ\), torej obstajata \(x\) in \(y\), da velja
  \(x ∈ σ ∧ x ∈ τ\) in \(y ∈ τ ∧ y ∈ ρ\). Ker je \(τ\) enojec je \(x = y\),
  torej velja \(x ∈ σ\) in \(x ∈ ρ\), kar po definiciji pomeni \(σ = ρ\).
\end{dokaz}
Ključno pri tej definiciji je, da smo podenojce sedaj opremili z razponom, tako
da obstajajo le tam, kjer imajo element. To pomeni, da postanejo enojci, zato
bomo od tu naprej podenojcem pravili enojci v spodnjem smislu.
\begin{lema}\label{lem:singunit}
  Za tip \(A\) veljata naslednji trditvi:
  \begin{enumerate}
  \item \(⊩ \for{σ:\g A}{\for{x:A}{\s x = σ ⇔ x ∈ σ}}\)
  \item \(⊩ \for{x,y:A}{\s x = \s y ⇔ x = y}\)
  \end{enumerate}
\end{lema}
\begin{dokaz}
  Fiksirajmo \(σ : \g A\) in \(x\), \(y:A\).
  \begin{enumerate}
  \item Če velja \(\s x = σ\), je potem \(x ∈ \s x = σ\). Obratno, če je
    \(x ∈ σ\), obstaja \(x' : A\) (namreč \(x\)), da je \(x = x'\) in
    \(x' ∈ σ\), torej je po definiciji \(\s x = σ\).
  \item Po prvi točki je \(\s x = \s y\) natanko \(x ∈ \s y\), torej velja \(x = y\).
    \qedhere 
  \end{enumerate}
\end{dokaz}

\begin{trditev}\label{th:subsing-is-sing}
  Za vsak tip \(A\) velja
  \[ ⊩ \for{σ : \g A}{\exist{x ∈ σ}{⊤}}\text. \]
\end{trditev}
\begin{dokaz}
  Če razpišemo gornje, dobimo \(\e σ ≤ \i{\exist{x : A}{x ∈ σ}}\) ampak \(\e σ\)
  je natanko \(\exist{x : A}{x ∈ σ ∧ x ∈ σ}\), torej je neenakosti zadoščeno.
\end{dokaz}
\begin{posledica}
  Velja \(⊩ \for{σ : \g A}{\exist{x : A}{σ = \s x}}\), torej so v internem jeziku
  vsi elementi \(\g A\) enojci.
\end{posledica}
Tako lahko res argumetiramo rabo besede ``enojec'' za elemente tipa \(\g A\).
Namreč, v notranjem jeziku je vsak element tipa \(\g A\) res enak enemu od
enojcev iz konstrukcije~\ref{cons:sing}. Opazimo pa lahko nekaj zanimivega.
Prazen podtip \(∅ = \set{x:A}{⊥}\) je enojec. Res, očitno sta vsaka dva njegova
elementa enaka, tako da je podenojec. To pomeni, da je element \(\g A\), kar
pomeni, da ima nek element, vsaj v internem jeziku. To ni problematično, saj je
\emph{razpon} tega enojca v \(\g A\) enak prazni množici, in nad prazno množico
res veljajo tudi napačne stvari, kot so "obstaja element prazne množice".
Pravilna interpretacija tega dejstva je potem, da v internem jeziku prazen
enojec ne obstaja, saj velja \(X ⊩ ¬‖∅‖\).

V trditvi~\ref{th:valid-local} smo videli, da se veljavnost znotraj lahko oža in
lepi. Če to uporabimo na tipu \(A\) iz primera~\ref{ex:one-to-one}, lahko
opazimo, da velja \(\{i\} ⊩ \exist{x:A}{⊤}\). Sedaj lahko to veljavnost po
trditvi~\ref{th:valid-glue} zlepimo v \(X ⊩ \exist{x:A}{⊤}\). Seveda noben
element \(A\) ne obstaja na celem \(X\), izkaže pa se, da obstaja ustrezen
\emph{enojec}, ki bo imel razpon \(X\). Ampak, da lahko govorimo o lepljenju,
moramo najprej skonstruirati zožitve.

\begin{konstrukcija}\label{cons:res}
  Naj bo \(a ∈ A\) in \(U ∈ 𝒪X\). Potem obstaja natanko en enojec
  \(a{\res U} ⊑ A\), za katerega velja
  \(\e a ⊩ \for{x:A}{x ∈ a{\res U} ⇔ x=a∧U}\) in \(\e{a{\res U}} = \e a∧U\).
\end{konstrukcija}
\begin{dokaz}
  Definirajmo \(a{\res U} ≔ \set{x:A}{x=a∧U}\). To je podenojec, saj če sta
  \(x\) in \(y\) njegova elementa, sta oba enaka \(a\), torej sta enaka. Po
  definiciji je to enoličen tak podtip, za katerega velja
  \(\e a ⊩ \for{x:A}{x ∈ a{\res U} ⇔ x=a∧U}\).
  Velja tudi \(\e{a{\res U}} = \exist{x:A}{x=a∧U} = \e a∧U\).
\end{dokaz}

\begin{konstrukcija}
  Naj bo \(I\) množica in \(a : I → A\) družina elementov, za katero za vse
  \(i\), \(j ∈ I\) velja \(\e{aᵢ}∩\e{aⱼ} ⊩ aᵢ = aⱼ\). Potem obstaja natanko en
  enojec \(∨a\), za katerega za vsak \(i ∈ I\) velja
  \(\e{aᵢ} ⊩ ∨a{\res{\e{aᵢ}}} = \s{aᵢ}\) in je \(\e{∨a} = ⋃ᵢ\e{aᵢ}\). 
\end{konstrukcija}
\begin{dokaz}
  Definirajmo \(∨a ≔ \set{x:A}{\exist{i:\c I}{x=aᵢ}}\). To je enojec, saj če sta
  \(x\) in \(y ∈ ⋁a\), za neka \(i\) in \(j\) velja \(x = aᵢ\) in \(y = aⱼ\).
  Iz prve enakosti dobimo, da velja \(\e{aᵢ}\), iz druge pa, da velja \(\e{aⱼ}\),
  saj je enakost relacija. Po predpostavki iz \(\e{aᵢ}∩\e{aⱼ}\) sledi \(aᵢ = aⱼ\),
  torej sta si \(x\) in \(y\) enaka.

  Po definiciji je \(aᵢ ∈ ∨a{\res{\e{aᵢ}}}\), saj je \(aᵢ=aᵢ\). Prav tako je
  razpon \(∨a\) enak uniji razponov elementov družine, saj na vsakem od njih
  obstaja element \(∨a\).

  Če je \(σ\) nek drug enojec, za katerega veljajo gornje enakosti, je na vsakem
  \(\e{aᵢ}\) enak \(∨a\), torej mu je enak tudi na celotnem razponu.
\end{dokaz}

Enojci nam torej dajo način, kako razširiti tip z vsemi zožitvami in zlepki
njenih elementov. Z drugimi besedami, tipe \emph{napolnimo} z zožitvami in
zlepki. Sedaj je vprašanje, kdaj se ta proces stabilizira.

\begin{definicija}\label{def:compl}
  Tip \(A\) je \emph{poln}, ko je funkcija \(\s - : A → \g A\) med množicama
  elementov tipov bijekcija. Polno podkategorijo polnih tipov označimo s
  \(\cat{CSet}(𝒪X)\).
\end{definicija}

Do sedaj smo delali z navadnimi tipi, ampak polni tipi imajo veliko želenih
lastonsti. A to pomeni, da moramo začeti znova s polnimi tipi? Namreč, do sedaj
smo imeli zgolj en primer polnega tipa, v primeru~\ref{ex:reals}. Izkaže se, da
ni tako.

% ⟨-⟩ definira idempotentno monado. To mi avtomatsko da naslednjih par
% rezultatov (specifično do izreka da so polne 𝒪X-množice refleksivna
% podkategorija).
\begin{lema}\label{th:compl-is-compl}
  Tip \(\g A\) je poln.
\end{lema}
\begin{dokaz}
  Pokazati moramo, da je preslikava \(σ ↦ \s σ\) bijekcija.
  Injektivnost sledi neposredno iz druge točke gornje leme, tako da pokažimo
  zgolj surjektivnost.
  % to je inverz enote (in je množenje).
  Naj bo \(Σ ∈ \g{\g A}\) in definirajmo \(τ ≔ \set{x : A}{\s x ∈ Σ}\).
  To je enojec, saj velja
  \[
    x∈τ ∧ y∈τ ⇔ \s x ∈ Σ ∧ \s y ∈ Σ ⇒ \s x = \s y ⇔ x = y\text.
  \]

  Pokažimo še, da je \(Σ = \s τ\), torej \(τ ∈ Σ\). To zadošča pokazati v
  internem jeziku, saj je \(τ ∈ Σ\) natanko tedaj, ko velja \(\e τ ⊩ τ ∈ Σ\).

  Ker je \(τ\) enojec obstaja nek \(a : A\), da je \(a ∈ τ\), torej je
  \(\s a ∈ Σ\). Poleg tega iz \(a ∈ τ\) sledi \(τ = \s a\), torej je
  \(τ ∈ Σ\).
  
  Sledi, da za vsak enojec v \(\g{\g A}\) obstaja natanko en enojec v \(\g A\),
  ki se vanj slika, tako da je preslikava \(\s -\) res bijekcija, in je \(\g A\)
  polna.
\end{dokaz}
\begin{opomba}
  Ta lema nam torej pove, da lahko \(\g A\) pravimo \emph{napolnitev} tipa \(A\).
\end{opomba}

Sedaj lahko vsakemu tipu priredimo poln tip. Še več, ta tip je izpeljana iz tipa
\(A\), torej lahko vse trditve o \(\g A\) izrazimo z \(A\) (specifično, z enojci
\(A\)). Se pa izkaže, da to ni potrebno, saj lahko trditve o \(\g A\) bolj
neposredno primerjamo s trditvami o \(A\).

\begin{izrek}\label{th:sigmaiso}
  Tip \(\g A\) je izomorfen \(A\).
\end{izrek}
\begin{dokaz}
  % {-} je enota monade σ, če je θ njen inverz, kaj je njena povezava z
  % množenjem? Plus lahko spustimo pol dokazov, da je {-} morfizem.
  Vemo že, da se \(A\) vloži v \(\g A\) z morfizmom \(a ↦ \s a\).
  Njegov inverz je \({θ(σ,a) ≔ \i{a ∈ σ}}\).
  Očitno velja \(θ(\s a, a)\). Oglejmo si potem drugi kompozitum. Da bo
  enak identiteti, mora za vsak \(σ : \g A\) obstajati \(a : A\), da je
  \(θ(σ,a)\) in \(σ=\s a\). Ta dva pogoja sta ekvivalentna \(a ∈ σ\), kar velja
  po definiciji razpona enojcev. Torej sta si morfizma inverzna, in velja
  \(\g A ≅ A\).
\end{dokaz}
\begin{posledica}\label{th:set-eq-cset}
  Kategorija tipov je ekvivalentna kategoriji polnih tipov.
\end{posledica}

Ekvivalenca nam omogoča, da izrek o tipih pretvorimo v izrek o polnih tipih, ga
dokažemo pod predpostavko polnosti, nato pa ga prenesemo nazaj na prvotni tip.
Povejmo bolj natančno, kako se to naredi.

Najprej, lahko vse relacije na \(A\) razširimo do relacij na \(\g A\). Tako bomo
lahko formule v internem jeziku s prosto spremenljivko tipa \(A\) razširili do
formule s prosto spremenljivko tipa \(\g A\).
\begin{konstrukcija}
  Naj bo \(R\) relacija na \(A\). Potem je
  \[ {\hat R(σ) ≔ \exist{x : A}{x ∈ σ∧R(x)}} \]
  edina relacija na \(\g A\), za katero za vse \(a ∈ A\) velja
  \(R(a) ⇔ \hat R(\s a)\).
\end{konstrukcija}
\begin{dokaz}
  Naj bo \(a ∈ A\). Očitno velja \(\hat R(\s a) ⇔ R(a)\), saj za \(x\) vzamemo
  kar \(a\). Naj bo \(Q\) neka druga relacija, in naj velja \(R(a) ⇔ Q(\s a)\).

  Naj bo \(σ : \g A\). Potem je enak nekemu \(\s a\), tako da preverimo zgolj,
  če je \(\hat R(\s a) ⇔ Q(\s a)\). Ampak ta sta po predpostavki oba \(R(a)\),
  torej sta enaka.
\end{dokaz}

\begin{izrek}\label{th:valid-compl}
  Formula \(φ\) je veljavna natanko tedaj, ko je veljavna formula, v kateri
  vse relacije \(R\) zamenjamo z \(\hat R\), vse domene kvantifikacije \(A\)
  zamenjamo z njihovimi napolnitvami \(\g A\), in vse konstante \(a\) zamenjamo
  z \(\s a\).
\end{izrek}
\begin{dokaz}
  Dokaz poteka po indukciji. Naredimo primer za univerzalni kvantifikator.
  Formula \(\for{x:A}{φ(x)}\) velja natanko tedaj, ko za vsak \(a ∈ A\) velja
  \(\e a ⇒ φ(a)\). Po drugi strani je formula \(\for{σ:\g A}{φ(σ)}\) veljavna
  natanko tedaj, ko za vsak enojec \(σ : A → 𝒪X\) velja
  \(\exist{x:A}{x ∈ σ} ⇒ φ(σ)\). Očitno sta za enojce \(\s a\) ta dva pogoja
  enaka, torej veljavnost formule za \(\g A\) implicira tisto za \(A\).

  Obratno, naj bo \(σ : A → 𝒪X\) poljuben enojec, in naj velja formula za \(A\).
  V internem jeziku je potem \(σ = \s a\) za nek \(a\), torej je
  \(φ(σ) ⇔ φ(\s a)\), ki drži po predpostavki.
\end{dokaz}

Ker je relacija \(\hat R\) edina, ki \(R\) razširi iz \(A\) na \(\g A\), jo
smemo označiti kar z \(R\). Prav tako, ker je \(\s -\) vložitev \(A\) v
\(\g A\), lahko terme tipa \(A\) obravnavamo kar kot terme tipa
\(\g A\). Izraz \(a ∈ τ\) bi morali spremeniti v \(\s a ∈ \s τ\), a lahko pišemo
kar \(a = τ\), saj \(a\) obravnavamo kot term tipa \(\g A\), tip \(\g{\g A}\) je
pa izomorfen \(\g A\), tako da lahko terme, ki bi pristali v \(\g{\g A}\) po
izomorfizmu prenesemo v \(\g A\).

% Oglejmo si najprej, kaj to pomeni na primeru.
% \begin{retrditev}{th:subsing-is-sing}
%   Za vsak \(A\) velja \(⊩ \for{σ : \g A}{\exist{x : A}{x ∈ σ}}\).
% \end{retrditev}
% \begin{dokaz}
%   Pokažimo to trditev ponovno, tokrat z uporabo izreka~\ref{th:valid-compl}.

%   Po gornjem izreku formula velja natanko tedaj, ko velja
%   \[ \for{σ:\g A}{\exist{x:\g A}{x = σ}}\text. \]
%   To je pa očitno res, saj za \(x\) vzamemo kar \(σ\).
% \end{dokaz}

To se torej izkaže za zelo koristno, saj pomeni, da lahko v interni logiki
uporabljamo vse lastnosti polnih tipov, ampak ko prevajamo formule v
zunanji svet pa lahko vseeno delamo le z začetnim naborom elementov.
To pomeni, da lahko na enojce tipa \(A\) gledamo kar kot na \emph{terme} tipa
\(A\). Pri tem moramo paziti, da so ti termi dobri le za dokazovanje obstoja v
internem jeziku. Gornji izrek nam namreč zagotavlja, da taka zamenjava ohranja
\emph{veljavnost} formul. Najpomembnejša posledica pa je, da če je \(f\)
morfizem, lahko na \(f[a]\) gledamo kot term tipa \(B\). Tako ga bomo pisali kar
\(f(a)\), kot bi pričakovali za element \(B\), ki je slika \(a\) z morfizmom
\(f\).

\begin{trditev}\label{th:ℒmor-into-compl-is-map}
  Naj bo \(f : A ↬ B \) in \(B\) poln tip. Tedaj obstaja natanko ena operacija
  \(φ : A ↝ B\), za katero velja \(\i{φ(a) = b} = f(a,b)\). 
\end{trditev}
\begin{dokaz}
  Za vsak \(a ∈ A\) je \(f[a]\) enojec, torej po polnosti \(B\) natanko
  določa en element \(B\), ki ga označimo \(φ(a)\). To definira preslikavo
  \(φ : A → B\). Ta je stroga, saj velja
  \(\e{φ(a)} = \exist{b:B}{b ∈ f[a]} = \e a\) in
  \(\i{a = a'} ⊆ \i{f(a) = f(a')} = \i{φ(a) = φ(a')}\).

  Po definiciji preslikave \(φ\) je \(φ(a) = b\) natanko tedaj, ko je
  \(b ∈ f(a)\), torej, ko velja \(f(a,b)\), tako da \(φ\) zadošča gornjemu
  pogoju.

  Naj bo \(ψ : A ↝ B\) neka druga operacija, ki prav tako zadošča gornjemu
  pogoju. Potem za vsak \(a ∈ A\) velja \(ψ(a) = φ(a)\) natanko tedaj, ko velja
  \(f(a,φ(a))\). 
\end{dokaz}
\begin{posledica}\label{th:set-eq-cset-with-maps}
  Kategorija polnih tipov je ekvivalentna kategoriji, katere
  \catdef
    {so polni tipi in}
    {so operacije}
\end{posledica}

To je teoretično zelo lepa struktura, a se izkaže, da je računsko neprijetna.
Namreč napolnitev tipa \(\c ℕ\) je \(𝒩\)~\cite{FH79}. Že dokaz dejstva, da je to
res, je dokaj neprijeten. Sloni na tem, da je vsaka lokalno konstantna
preslikava zlepek zožitev konstantnih preslikav. Torej, ker so elementi
napolnitve ravno zlepki in zožitve, se \(𝒩\) vloži v \(\g{\c ℕ}\). Obratno je
vsak enojec v internem jeziku \emph{lokalno} enak nekemu naravnemu številu. To
potem definira lokalno konstantno funkcijo v \(ℕ\). Sedaj moramo pokazati še, da
sta ti preslikavi operaciji, in da sta si inverzni. Poleg tega obstaja veliko
konstrukcij tipov, ki postanejo bolj komplicirane, ko jih napolnimo. Te bomo
videli v naslednjem podrazdelku.


\subsubsection{Lastnosti morfizmov}

Za konec lahko izračunamo nekaj koristnih lastnosti morfizmov. Zgoraj smo že
povedali, da lahko pod določenimi pogoji vrednosti funkcij obravnavamo kot terme
tipa kodomene. Videli smo že, da lahko pišemo \(f(a) = b\) namesto \(f(a,b)\),
ampak nam to omogoča tudi druge koristne okrajšave.

\begin{lema}
  Morfizma \(f\) in \(g : A ↬ B\) sta enaka natanko tedaj, ko velja 
  \[ ⊩ \for{x : A}{f(x) = g(x)}\text. \]
\end{lema}
\begin{dokaz}
  Če sta \(f\) in \(g\) enaka potem formula očitno velja.
  
  Pokažemo sedaj drugo smer previdno, brez posebne rabe notranje polnosti \(B\).

  Predpostavimo torej, da velja gornja formula, in da velja \(f(a,b)\) za neka
  \(a\) in \(b\). Potem po predpostavki vemo, da velja \(f(a) = g(a)\). Če to
  enakost razpišemo, dobimo, da obstaja \(b' ∈ B\), tako da veljata \(f(a,b')\)
  in \(g(a,b')\). Potem zaradi enoličnosti \(f\) dobimo \(b = b'\), torej velja
  tudi \(g(a,b)\). Ker je vloga \(f\) in \(g\) simetrična, ter sta \(a\) in
  \(b\) poljubna, velja \(f(a,b)\) natanko tedaj, ko velja \(g(a,b)\), torej sta
  \(f\) in \(g\) enaka.
\end{dokaz}

Gornji lemi se ponavadi pravi \emph{funkcionalna ekstenzionalnost}, saj pravi da
sta si funkciji enaki natanko tedaj, ko sta enaki na vseh vrednostih. Izkaže se
tudi, da je to primerna relacija za definicijo \emph{tipa} morfizmov iz \(A\) v
\(B\).

\begin{konstrukcija}\label{cons:exponent}
  \emph{Eksponentni tip} \(A ↬ B\) je množica morfizmov \(A ↬ B\) z
  enakostjo \(f=g ⇔ \for{x:A}{f(x)=g(x)}\).
\end{konstrukcija}
\begin{dokaz}
  To je tip, saj je relacija očitno simetrična in tranzitivna.
  Pokazati je torej treba le, da obstaja morfizem \(\ev : (A↬B)×A ↬ B\), za
  katerega velja, da za vsak \(e : C×A ↬ B\) obstaja enolična preslikava
  \(u : C ↬ A ↬ B\), da je \(e = \ev∘(u×\id)\). Če to enakost zapišemo na
  elementih dobimo, da mora veljati
  \[ e(c,a) = \ev∘(u×\id)(c,a) = \ev(u(c),a) = u(c)(a)\text. \]
  To nam enolično določa preslikavo \(u\) in je dokaz končan.
\end{dokaz}
Standardna oznaka za eksponentni tip je \(B^A\), a tu raje uporabimo
\({A ↬ B}\), da ne bomo mešali eksponentnega tipa z množico preskikav iz \(A\) v
\(B\). 

\begin{trditev}\label{th:Ω-is-subobj-class}
  Tip \(Ω\) je \emph{klasifikator podobojektov}.
  % množica \(𝒪X\) skupaj z enakostjo \(⇔\) in ga označimo \(Ω\).
\end{trditev}
\begin{dokaz}
  V trditvah~\ref{th:ℒsub-is-map-to-Ω} in~\ref{th:ℒsub-is-sub} smo že pokazali,
  da lahko vsakemu monomorfizmu \({m : S ↬ A}\) priredimo enoličen morfizem
  \(χ_S : A ↬ Ω\), da je \(S ≅ χ_S⁻¹(⊤)\), torej je \(Ω\) res klasifikator
  podobjektov.
\end{dokaz}

Kot ponavadi definiramo potenčni tip \(𝒫A\) kot eksponent \(A ↬ Ω\), a kot
smo povedali že v trditvi~\ref{th:ℒsub-is-map-to-Ω}, so to natanko podtipi.

\begin{konstrukcija}\label{cons:subobjs}
  \emph{Tip podtipov \(A\)} oziroma \emph{potenčni tip \(A\)} je eksponentni
  tip \(A ↬ Ω\). Ta je enak tipu na množici podtipov \(A\), z isto enakostjo kot
  na ekponentnem tipu. Označimo ga z \(𝒫{A}\).
\end{konstrukcija}
% \begin{dokaz}
%   V~\ref{th:ℒsub-is-map-to-Ω} smo pokazali, da sta množici izomorfni. Poleg
%   tega, je \(S =_{A ↬ Ω} T\) natanko tedaj, ko \(\for{x:A}{x ∈ S ⇔ x ∈ T}\),
%   torej ko je \(S(a) = T(a)\) za vse \(a ∈ A\). To pa natanko pomeni, da sta
%   \(S\) in \(T\) enaka kot preslikavi, torej enaka v konstantem tipu.
% \end{dokaz}

Sedaj, ko imamo dostop do vrednosti morfizmov, pa lahko karakteriziramo
epimorfizme in monomorfizme. V običajni teoriji množic so te natanko surjekcije
in injekcije, kar se izkaže za resnično tudi za morfizme med tipi.

Najprej pa konstruirajmo še nekaj konstrukcij tipov, saj jih potrebujemo
v dokazu.
\begin{konstrukcija}
  Za tipa \(A\) in \(B\) je množica \(A+B\) z enakostjo generirano z relacijami
  \(ι₀(x) = ι₀(x') ⇔ x=x'\) in \(ι₁(y) = ι₁(y') ⇔ y=y'\), kjer sta \(x\) in
  \(x'\) prosti spremenljivki tipa \(A\), \(y\) in \(y'\) pa tipa \(B\).
  Označimo ga kar z \(A+B\). Poleg tega sta kanonični vložitvi \(ιᵢ\) operaciji.
\end{konstrukcija}
\begin{dokaz}
  Pokazati je treba, da sta vložitvi strogi in ekstenzionalni.
  Brez škode za splošnost lahko to pokažemo zgolj za \(ι : A → A+B\).
  Pri obeh lastnostih, ki jih moramo preveriti, je enakost na \(A+B\) vedno med
  elementi prve komponente, tako da se \(ι(a) = ι(a')\) vedno prevede kar na
  \(a = a'\). Potem je \(ι\) očitno stroga in ekstenzionalna.
\end{dokaz}
\begin{konstrukcija}
  \emph{Kojedro} morfizma \(f : A ↬ B\) je zlepek tipov \(B\) in \(B\) po
  podmnožici \(f[A]\). Označimo ga \(\coker(f)\).
\end{konstrukcija}
\begin{dokaz}
  Kot v Uvodu v geometrijsko topologijo ta zlepek konstruiramo kot kvocient
  tipa \(B+B\) po relaciji generirani z \(ι₁(b) \sim ι₂(b) ⇔ b ∈ f[A]\).
\end{dokaz}

\begin{definicija}
  Morfizem \(f : A ↬ B\) je \emph{surjektiven}, ko velja
  \[ ⊩ \for{y : B}{y ∈ f[A]}\text, \]
  in \emph{injektiven}, ko velja
  \[ ⊩ \for{x,y:A}{f(x) = f(y) ⇒ x = y}\text. \]
\end{definicija}
\begin{trditev}
  Surjekcije so natanko epimorfizmi v \(\cat{Set}{\p{𝒪X}}\).
\end{trditev}
\begin{dokaz}
  Naj bo \(f : A ↬ B\).

  Denimo, da je \(f\) surjektiven, \(g\) in \(h : B ↬ C\), in \(g ∘ f = h ∘ f\).
  Naj bo \(b : B\) in dokažimo \(g(b) = h(b)\).
  Po surjektivnosti obstaja \(a : A\), da je \(b = f(a)\), torej sledi
  \(g(b) = g(f(a)) = h(f(a)) = h(b)\).

  Po drugi strani predpostavimo, da je \(f\) epimorfizem.
  Poglejmo si potem vložitvi v kojedro \(ι₁,ι₂ : B ↬ \coker(f)\).
  Te \(f\) po konstrukciji očitno izenači, saj je \(\coker(f)\) ravno zlepek
  kopij \(B\) po sliki \(f\). Torej sta po predpostavki enaki, saj je \(f\)
  epimorfizem. Tedaj za vsak \(b : B\) velja, da je \(ι₁(b) = ι₂(b)\), torej
  da je \(b ∈ f[A]\).
\end{dokaz}

\begin{trditev}
  Injekcije so natanko monomorfizmi v \(\cat{Set}{\p{𝒪X}}\).
\end{trditev}
\begin{dokaz}
  Naj bo \(f : B ↬ C\).

  Denimo, da je \(f\) injektiven, \(g\) in \(h : A ↬ B\), in \(f ∘ g = f ∘ h\).
  Naj bo \(a : A\) in dokažimo \(g(a) = h(a)\).
  Vemo, da je \(f(g(a)) = f(h(a))\). Po injektivnosti to potem pomeni, da velja
  \(g(a) = h(a)\), kar smo tudi želeli.

  Obratno, naj bo \(f\) monomorfizem in \(a\), \(a' : A\).
  Denimo, da velja \(f(a) = f(a')\) in naj bosta \(g, h : \bb1 ↬ A\) definirana
  s predpisoma \(g(*) ≔ a\) ter \(h(*) ≔ a'\), torej velja
  \(f(g(*)) = f(a) = f(a') = f(h(*))\) in je \(f∘g = f∘h\). Od tod
  sledi, da je \(g = h\), torej velja \(a = g(*) = h(*) = a'\).
\end{dokaz}

Sedaj se pa želimo vprašati, kaj so bijekcije tipov. V teoriji množic vemo, da
so to ravno izomorfizmi, in res to velja tudi pri nas. Za morfizem \(f : A ↬ B\)
lahko definiramo dual \(fᵒ : B×A → 𝒪X\) s predpisom \(fᵒ(b,a) ≔ f(a,b)\).
Kompozituma z dualom sta identiteti, tako da je zares treba pokazati, da je \(fᵒ\)
morfizem.

\begin{trditev}
  Za \(f : A ↬ B\) je \(fᵒ\) morfizem natanko tedaj, ko je \(f\) bijektiven.
  V tem primeru potem velja \(f∘fᵒ = \id = fᵒ∘f\), torej je \(fᵒ\) inverz \(f\).
\end{trditev}
\begin{dokaz}
  Opazimo da je \(fᵒ\) res celovita natanko tedaj, ko je \(f\) surjektivna, in
  da je enolična natanko tedaj, ko je \(f\) injektivna.
  Pokažimo sedaj le eno neenakost, saj je druga simetrična.

  Naj bo \(a = fᵒ(f(a'))\), torej \(f(a)=f(a')\). Ker je \(f\) bijektivna, je
  \(a = a'\), in velja \(\id = fᵒ∘f\).
\end{dokaz}

Karakterizirajmo še razred eksponentov s konstantnim tipom \(\c A ↬ B\). Ti
predstavljajo ``\(A\)-mnoge produkte tipa \(B\)'' in se izkaže, da imajo nad
lokalno povezanimi prostori posebej lepo karakterizacijo.
\begin{trditev}\label{th:lpov-exponentiable}
  Če je \(X\) lokalno povezan in \(A\) množica, velja
  \(⊩ \c A ↬ B ≅ \c{A ↝ B}\).
\end{trditev}
\begin{dokaz}
  Naj bodo \(f : \c A ↬ B\), \(g : \c{A ↝ B}\), in \(a : \c A\).
  Najprej, obstja pokritje \(C\), tako da sta na njem \(g\) in \(a\) konstantna.
  Zaradi lokalne povezanosti, lahko predpostavimo, da je \(C\) zares particija.
  Potem lahko \(f(a) = g(a)\) definiramo na \(U ∈ C\) preprosto kot
  \(f(a,g(a))\), saj na vsakem elementu \(C\) velja \(g(a) ∈ B\).

  Definirajmo morfizem \(φ(f,g) ≔ \for{x:\c A}{f(x) = g(x)}\).
  Če velja \(φ(f) = φ(f')\), za vse \(x : \c A\) velja \(f(x) = f'(x)\), torej
  je \(φ\) injektivna.
  Za surjektivnost naj bo \(g : \c{A ↝ B}\) in definirajmo
  \(f(a, b) ≔ ⋃\set{U ∈ C}{U ⊩ g(a) = b}\).
  Za tega velja \(f(x) = g(x)\), torej velja \(φ(f,g)\).
  Sledi, da je \(φ\) izomorfizem med \(\c A ↬ \c B\) in \(\c{A ↝ B}\).
\end{dokaz}
\begin{opomba}
  Če je tip \(B\) konstanten, je množica operacij natanko množica navadnih
  preslikav, tako da izrek v tem primeru pravi \(⊩ \c A ↬ \c B ≅ \c{B^A}\).
\end{opomba}

% \begin{trditev}
%   Objekt \(\c{B^A}\) je znotraj enak topološkemu prostoru \(B^A\) s kompaktno
%   odprto topologijo.
% \end{trditev}
% \begin{dokaz}
%   Naj bo \(σ\) enojec tipa \(\c{B^A}\). Potem slika elemente množice \(B^A\) v
%   elemente \(𝒪X\). Če je \(t ∈ \e σ\), je \(\set{f : A → B}{t ⊩ f ∈ σ}\)
%   podmnožica \(B^A\).
% \end{dokaz}


%%% Local Variables:
%%% TeX-master: "main"
%%% End:
